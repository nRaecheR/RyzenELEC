diff -Nuar mc-4.8.26-orig/AUTHORS mc-4.8.26/AUTHORS
--- mc-4.8.26-orig/AUTHORS	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/AUTHORS	2021-02-13 11:01:18.937533889 +0000
@@ -43,9 +43,6 @@
 Alessandro Rubini <rubini@ipvvis.unipv.it>
 	Mouse support.
 
-Aleš Janda <ales.janda@kyblsoft.cz>
-	Shadows of dialog windows and menus.
-
 Alexander Dong <ado@software-ag.de>
 	OS/2 port.
 
diff -Nuar mc-4.8.26-orig/doc/man/mc.1.in mc-4.8.26/doc/man/mc.1.in
--- mc-4.8.26-orig/doc/man/mc.1.in	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/doc/man/mc.1.in	2021-02-13 11:01:18.940867268 +0000
@@ -2113,17 +2113,13 @@
 directory hotlist entries deletion and history cleanup.
 .\"NODE "    Appearance"
 .SH "    Appearance"
-In this dialog you can select the skin to be used and enable shadow
-for dialogs and drop down menus.
+In this dialog you can select the skin to be used.
 .PP
 See the
 .\"LINK2"
 Skins
 .\"Skins"
 section for technical details about the skin definition files.
-.PP
-.I Shadows.
-If this option is enabled, all dialogs and drop down menus will have a shadow.
 .\"NODE "    Display bits"
 .SH "    Display bits"
 This is used to configure the range of visible characters on the
diff -Nuar mc-4.8.26-orig/doc/man/ru/mc.1.in mc-4.8.26/doc/man/ru/mc.1.in
--- mc-4.8.26-orig/doc/man/ru/mc.1.in	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/doc/man/ru/mc.1.in	2021-02-13 11:01:18.944200647 +0000
@@ -2411,17 +2411,12 @@
 на подтверждение.
 .\"NODE "    Appearance"
 .SH "    Оформление"
-Используя это диалоговое окно, вы можете выбрать скин и разрещить отрисовку
-теней у диалоговых окон и выпадающих меню.
+Используя это диалоговое окно, вы можете выбрать скин.
 .PP
 Для получения более подробной информации о скинах обратитесь к разделу
 .\"LINK2"
 Внешний вид\&.
 .\"Skins"
-.PP
-.I Тени.
-Если эта опция включена, все диалоговые окна и выпадающие меню будут иметь
-тени.
 .\"NODE "    Display bits"
 .SH "    Биты символов..."
 Этот пункт меню используется для задания диапазона отображаемых на
diff -Nuar mc-4.8.26-orig/lib/global.c mc-4.8.26/lib/global.c
--- mc-4.8.26-orig/lib/global.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/global.c	2021-02-13 11:01:18.947534027 +0000
@@ -83,7 +83,6 @@
     .tty =
     {
         .skin = NULL,
-        .shadows = TRUE,
         .setup_color_string = NULL,
         .term_color_string = NULL,
         .color_terminal_string = NULL,
diff -Nuar mc-4.8.26-orig/lib/global.c.orig mc-4.8.26/lib/global.c.orig
--- mc-4.8.26-orig/lib/global.c.orig	1970-01-01 00:00:00.000000000 +0000
+++ mc-4.8.26/lib/global.c.orig	2021-01-10 11:50:16.000000000 +0000
@@ -0,0 +1,130 @@
+/*
+   Global structure for some library-related variables
+
+   Copyright (C) 2009-2020
+   Free Software Foundation, Inc.
+
+   Written by:
+   Slava Zanko <slavazanko@gmail.com>, 2009.
+
+   This file is part of the Midnight Commander.
+
+   The Midnight Commander is free software: you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation, either version 3 of the License,
+   or (at your option) any later version.
+
+   The Midnight Commander is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file glibcompat.c
+ *  \brief Source: global structure for some library-related variables
+ *
+ */
+
+#include <config.h>
+
+#include "global.h"
+
+/* *INDENT-OFF* */
+#ifdef ENABLE_SUBSHELL
+#  ifdef SUBSHELL_OPTIONAL
+#    define SUBSHELL_USE FALSE
+#  else /* SUBSHELL_OPTIONAL */
+#    define SUBSHELL_USE TRUE
+#  endif /* SUBSHELL_OPTIONAL */
+#else /* !ENABLE_SUBSHELL */
+#    define SUBSHELL_USE FALSE
+#endif /* !ENABLE_SUBSHELL */
+/* *INDENT-ON* */
+
+/*** global variables ****************************************************************************/
+
+/* *INDENT-OFF* */
+mc_global_t mc_global = {
+    .mc_run_mode = MC_RUN_FULL,
+    .run_from_parent_mc = FALSE,
+    .midnight_shutdown = FALSE,
+
+    .sysconfig_dir = NULL,
+    .share_data_dir = NULL,
+
+#ifdef HAVE_CHARSET
+    .source_codepage = -1,
+    .display_codepage = -1,
+#else
+    .eight_bit_clean = TRUE,
+    .full_eight_bits = FALSE,
+#endif /* !HAVE_CHARSET */
+    .utf8_display = FALSE,
+
+    .message_visible = TRUE,
+    .keybar_visible = TRUE,
+
+#ifdef ENABLE_BACKGROUND
+    .we_are_background = FALSE,
+#endif /* ENABLE_BACKGROUND */
+
+    .widget =
+    {
+        .confirm_history_cleanup = TRUE,
+        .show_all_if_ambiguous = FALSE,
+        .is_right = FALSE
+    },
+
+    .shell = NULL,
+
+    .tty =
+    {
+        .skin = NULL,
+        .shadows = TRUE,
+        .setup_color_string = NULL,
+        .term_color_string = NULL,
+        .color_terminal_string = NULL,
+        .command_line_colors = NULL,
+#ifndef LINUX_CONS_SAVER_C
+        .console_flag = '\0',
+#endif /* !LINUX_CONS_SAVER_C */
+
+        .use_subshell = SUBSHELL_USE,
+
+#ifdef ENABLE_SUBSHELL
+        .subshell_pty = 0,
+#endif /* !ENABLE_SUBSHELL */
+
+        .xterm_flag = FALSE,
+        .disable_x11 = FALSE,
+        .slow_terminal = FALSE,
+        .disable_colors = FALSE,
+        .ugly_line_drawing = FALSE,
+        .old_mouse = FALSE,
+        .alternate_plus_minus = FALSE
+    },
+
+    .vfs =
+    {
+        .cd_symlinks = TRUE,
+        .preallocate_space = FALSE,
+    }
+
+};
+/* *INDENT-ON* */
+
+#undef SUBSHELL_USE
+
+/*** file scope macro definitions ****************************************************************/
+
+/*** file scope type declarations ****************************************************************/
+
+/*** file scope variables ************************************************************************/
+
+/*** file scope functions ************************************************************************/
+
+/*** public functions ****************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
diff -Nuar mc-4.8.26-orig/lib/global.h mc-4.8.26/lib/global.h
--- mc-4.8.26-orig/lib/global.h	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/global.h	2021-02-13 11:01:18.947534027 +0000
@@ -226,8 +226,6 @@
     {
         /* Use the specified skin */
         char *skin;
-        /* Dialog window and frop down menu have a shadow */
-        gboolean shadows;
 
         char *setup_color_string;
         char *term_color_string;
diff -Nuar mc-4.8.26-orig/lib/global.h.orig mc-4.8.26/lib/global.h.orig
--- mc-4.8.26-orig/lib/global.h.orig	1970-01-01 00:00:00.000000000 +0000
+++ mc-4.8.26/lib/global.h.orig	2021-01-10 11:50:16.000000000 +0000
@@ -0,0 +1,293 @@
+/** \file global.h
+ *  \brief Header: %global definitions for compatibility
+ *
+ *  This file should be included after all system includes and before all local includes.
+ */
+
+#ifndef MC_GLOBAL_H
+#define MC_GLOBAL_H
+
+#if defined(HAVE_STRING_H)
+#include <string.h>
+   /* An ANSI string.h and pre-ANSI memory.h might conflict */
+#elif defined(HAVE_MEMORY_H)
+#include <memory.h>
+#else
+#include <strings.h>
+    /* memory and strings.h conflict on other systems */
+#endif /* !STDC_HEADERS & !HAVE_STRING_H */
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+
+/* for O_* macros */
+#include <fcntl.h>
+
+/* for sig_atomic_t */
+#include <signal.h>
+
+#ifdef HAVE_FUNC_ATTRIBUTE_FALLTHROUGH
+#define MC_FALLTHROUGH __attribute__((fallthrough))
+#else
+#define MC_FALLTHROUGH
+#endif
+
+/*** typedefs(not structures) and defined constants **********************************************/
+
+/* The O_BINARY definition was taken from gettext */
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+#define O_BINARY _O_BINARY
+#endif
+#ifdef __BEOS__
+  /* BeOS 5 has O_BINARY, but is has no effect.  */
+#undef O_BINARY
+#endif
+/* On reasonable systems, binary I/O is the default.  */
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+
+/* Replacement for O_NONBLOCK */
+#ifndef O_NONBLOCK
+#ifdef O_NDELAY                 /* SYSV */
+#define O_NONBLOCK O_NDELAY
+#else /* BSD */
+#define O_NONBLOCK FNDELAY
+#endif /* !O_NDELAY */
+#endif /* !O_NONBLOCK */
+
+#if defined(__QNX__) && !defined(__QNXNTO__)
+/* exec*() from <process.h> */
+#include <unix.h>
+#endif
+
+#include <glib.h>
+#include "glibcompat.h"
+
+/* For SMB VFS only */
+#ifndef __GNUC__
+#define __attribute__(x)
+#endif
+
+/* Solaris9 doesn't have PRIXMAX */
+#ifndef PRIXMAX
+#define PRIXMAX PRIxMAX
+#endif
+
+#ifdef ENABLE_NLS
+#include <libintl.h>
+#define _(String) gettext (String)
+#ifdef gettext_noop
+#define N_(String) gettext_noop (String)
+#else
+#define N_(String) (String)
+#endif
+#else /* Stubs that do something close enough.  */
+#define textdomain(String) 1
+#define gettext(String) (String)
+#define ngettext(String1,String2,Num) (((Num) == 1) ? (String1) : (String2))
+#define dgettext(Domain,Message) (Message)
+#define dcgettext(Domain,Message,Type) (Message)
+#define bindtextdomain(Domain,Directory) 1
+#define _(String) (String)
+#define N_(String) (String)
+#endif /* !ENABLE_NLS */
+
+#include "fs.h"
+#include "shell.h"
+#include "mcconfig.h"
+
+#ifdef USE_MAINTAINER_MODE
+#include "lib/logging.h"
+#endif
+
+/* Just for keeping Your's brains from invention a proper size of the buffer :-) */
+#define BUF_10K 10240L
+#define BUF_8K  8192L
+#define BUF_4K  4096L
+#define BUF_1K  1024L
+
+#define BUF_LARGE  BUF_1K
+#define BUF_MEDIUM 512
+#define BUF_SMALL 128
+#define BUF_TINY 64
+
+/* ESC_CHAR is defined in /usr/include/langinfo.h in some systems */
+#ifdef ESC_CHAR
+#undef ESC_CHAR
+#endif
+/* AIX compiler doesn't understand '\e' */
+#define ESC_CHAR '\033'
+#define ESC_STR  "\033"
+
+/* OS specific defines */
+#define PATH_SEP '/'
+#define PATH_SEP_STR "/"
+#define IS_PATH_SEP(c) ((c) == PATH_SEP)
+#define PATH_ENV_SEP ':'
+#define TMPDIR_DEFAULT "/tmp"
+#define SCRIPT_SUFFIX ""
+#define get_default_editor() "vi"
+#define OS_SORT_CASE_SENSITIVE_DEFAULT TRUE
+#define UTF8_CHAR_LEN 6
+
+/* struct stat members */
+#ifdef __APPLE__
+#define st_atim st_atimespec
+#define st_ctim st_ctimespec
+#define st_mtim st_mtimespec
+#endif
+
+/* Used to distinguish between a normal MC termination and */
+/* one caused by typing 'exit' or 'logout' in the subshell */
+#define SUBSHELL_EXIT 128
+
+#define MC_ERROR g_quark_from_static_string (PACKAGE)
+
+#define DEFAULT_CHARSET "ASCII"
+
+/*** enums ***************************************************************************************/
+
+/* run mode and params */
+typedef enum
+{
+    MC_RUN_FULL = 0,
+    MC_RUN_EDITOR,
+    MC_RUN_VIEWER,
+    MC_RUN_DIFFVIEWER
+} mc_run_mode_t;
+
+/*** structures declarations (and typedefs of structures)*****************************************/
+
+typedef struct
+{
+    mc_run_mode_t mc_run_mode;
+    gboolean run_from_parent_mc;
+    /* Used so that widgets know if they are being destroyed or shut down */
+    gboolean midnight_shutdown;
+
+    /* sysconfig_dir: Area for default settings from maintainers of distributuves
+       default is /etc/mc or may be defined by MC_DATADIR */
+    char *sysconfig_dir;
+    /* share_data_dir: Area for default settings from developers */
+    char *share_data_dir;
+
+    mc_config_t *main_config;
+    mc_config_t *panels_config;
+
+#ifdef HAVE_CHARSET
+    /* Numbers of (file I/O) and (input/display) codepages. -1 if not selected */
+    int source_codepage;
+    int display_codepage;
+#else
+    /* If true, allow characters in the range 160-255 */
+    gboolean eight_bit_clean;
+    /*
+     * If true, also allow characters in the range 128-159.
+     * This is reported to break on many terminals (xterm, qansi-m).
+     */
+    gboolean full_eight_bits;
+#endif                          /* !HAVE_CHARSET */
+    /*
+     * If utf-8 terminal utf8_display = TRUE
+     * Display bits set UTF-8
+     */
+    gboolean utf8_display;
+
+    /* Set if the nice message (hint) bar is visible */
+    gboolean message_visible;
+    /* Set if the nice and useful keybar is visible */
+    gboolean keybar_visible;
+
+#ifdef ENABLE_BACKGROUND
+    /* If true, this is a background process */
+    gboolean we_are_background;
+#endif                          /* ENABLE_BACKGROUND */
+
+    struct
+    {
+        /* Asks for confirmation before clean up of history */
+        gboolean confirm_history_cleanup;
+
+        /* Set if you want the possible completions dialog for the first time */
+        gboolean show_all_if_ambiguous;
+
+        /* Ugly hack in order to distinguish between left and right panel in menubar */
+        /* Set if the command is being run from the "Right" menu */
+        gboolean is_right;      /* If the selected menu was the right */
+    } widget;
+
+    /* The user's shell */
+    mc_shell_t *shell;
+
+    struct
+    {
+        /* Use the specified skin */
+        char *skin;
+        /* Dialog window and frop down menu have a shadow */
+        gboolean shadows;
+
+        char *setup_color_string;
+        char *term_color_string;
+        char *color_terminal_string;
+        /* colors specified on the command line: they override any other setting */
+        char *command_line_colors;
+
+#ifndef LINUX_CONS_SAVER_C
+        /* Used only in mc, not in cons.saver */
+        char console_flag;
+#endif                          /* !LINUX_CONS_SAVER_C */
+        /* If using a subshell for evaluating commands this is true */
+        gboolean use_subshell;
+
+#ifdef ENABLE_SUBSHELL
+        /* File descriptors of the pseudoterminal used by the subshell */
+        int subshell_pty;
+#endif                          /* !ENABLE_SUBSHELL */
+
+        /* This flag is set by xterm detection routine in function main() */
+        /* It is used by function toggle_subshell() */
+        gboolean xterm_flag;
+
+        /* disable x11 support */
+        gboolean disable_x11;
+
+        /* For slow terminals */
+        /* If true lines are shown by spaces */
+        gboolean slow_terminal;
+
+        /* Set to force black and white display at program startup */
+        gboolean disable_colors;
+
+        /* If true use +, -, | for line drawing */
+        gboolean ugly_line_drawing;
+
+        /* Tries to use old highlight mouse tracking */
+        gboolean old_mouse;
+
+        /* If true, use + and \ keys normally and select/unselect do if M-+ / M-\.
+           and M-- and keypad + / - */
+        gboolean alternate_plus_minus;
+    } tty;
+
+    struct
+    {
+        /* Set when cd symlink following is desirable (bash mode) */
+        gboolean cd_symlinks;
+
+        /* Preallocate space before file copying */
+        gboolean preallocate_space;
+
+    } vfs;
+} mc_global_t;
+
+/*** global variables defined in .c file *********************************************************/
+
+extern mc_global_t mc_global;
+
+/*** declarations of public functions ************************************************************/
+
+/*** inline functions ****************************************************************************/
+#endif
diff -Nuar mc-4.8.26-orig/lib/skin/colors.c mc-4.8.26/lib/skin/colors.c
--- mc-4.8.26-orig/lib/skin/colors.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/skin/colors.c	2021-02-13 11:01:18.947534027 +0000
@@ -249,7 +249,6 @@
     REVERSE_COLOR = mc_skin_color_get ("core", "reverse");
     HEADER_COLOR = mc_skin_color_get ("core", "header");
     COMMAND_MARK_COLOR = mc_skin_color_get ("core", "commandlinemark");
-    SHADOW_COLOR = mc_skin_color_get ("core", "shadow");
 
     COLOR_NORMAL = mc_skin_color_get ("dialog", "_default_");
     COLOR_FOCUS = mc_skin_color_get ("dialog", "dfocus");
diff -Nuar mc-4.8.26-orig/lib/skin.h mc-4.8.26/lib/skin.h
--- mc-4.8.26-orig/lib/skin.h	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/skin.h	2021-02-13 11:01:18.947534027 +0000
@@ -22,93 +22,92 @@
 #define REVERSE_COLOR             mc_skin_color__cache[6]
 #define COMMAND_MARK_COLOR        mc_skin_color__cache[7]
 #define HEADER_COLOR              mc_skin_color__cache[8]
-#define SHADOW_COLOR              mc_skin_color__cache[9]
 
 /* Dialog colors */
-#define COLOR_NORMAL              mc_skin_color__cache[10]
-#define COLOR_FOCUS               mc_skin_color__cache[11]
-#define COLOR_HOT_NORMAL          mc_skin_color__cache[12]
-#define COLOR_HOT_FOCUS           mc_skin_color__cache[13]
-#define COLOR_TITLE               mc_skin_color__cache[14]
+#define COLOR_NORMAL              mc_skin_color__cache[9]
+#define COLOR_FOCUS               mc_skin_color__cache[10]
+#define COLOR_HOT_NORMAL          mc_skin_color__cache[11]
+#define COLOR_HOT_FOCUS           mc_skin_color__cache[12]
+#define COLOR_TITLE               mc_skin_color__cache[13]
 
 /* Error dialog colors */
-#define ERROR_COLOR               mc_skin_color__cache[15]
-#define ERROR_FOCUS               mc_skin_color__cache[16]
-#define ERROR_HOT_NORMAL          mc_skin_color__cache[17]
-#define ERROR_HOT_FOCUS           mc_skin_color__cache[18]
-#define ERROR_TITLE               mc_skin_color__cache[19]
+#define ERROR_COLOR               mc_skin_color__cache[14]
+#define ERROR_FOCUS               mc_skin_color__cache[15]
+#define ERROR_HOT_NORMAL          mc_skin_color__cache[16]
+#define ERROR_HOT_FOCUS           mc_skin_color__cache[17]
+#define ERROR_TITLE               mc_skin_color__cache[18]
 
 /* Menu colors */
-#define MENU_ENTRY_COLOR          mc_skin_color__cache[20]
-#define MENU_SELECTED_COLOR       mc_skin_color__cache[21]
-#define MENU_HOT_COLOR            mc_skin_color__cache[22]
-#define MENU_HOTSEL_COLOR         mc_skin_color__cache[23]
-#define MENU_INACTIVE_COLOR       mc_skin_color__cache[24]
+#define MENU_ENTRY_COLOR          mc_skin_color__cache[19]
+#define MENU_SELECTED_COLOR       mc_skin_color__cache[20]
+#define MENU_HOT_COLOR            mc_skin_color__cache[21]
+#define MENU_HOTSEL_COLOR         mc_skin_color__cache[22]
+#define MENU_INACTIVE_COLOR       mc_skin_color__cache[23]
 
 /* Popup menu colors */
-#define PMENU_ENTRY_COLOR         mc_skin_color__cache[25]
-#define PMENU_SELECTED_COLOR      mc_skin_color__cache[26]
-#define PMENU_HOT_COLOR           mc_skin_color__cache[27]      /* unused: not implemented yet */
-#define PMENU_HOTSEL_COLOR        mc_skin_color__cache[28]      /* unused: not implemented yet */
-#define PMENU_TITLE_COLOR         mc_skin_color__cache[29]
+#define PMENU_ENTRY_COLOR         mc_skin_color__cache[24]
+#define PMENU_SELECTED_COLOR      mc_skin_color__cache[25]
+#define PMENU_HOT_COLOR           mc_skin_color__cache[26]      /* unused: not implemented yet */
+#define PMENU_HOTSEL_COLOR        mc_skin_color__cache[27]      /* unused: not implemented yet */
+#define PMENU_TITLE_COLOR         mc_skin_color__cache[28]
 
-#define BUTTONBAR_HOTKEY_COLOR    mc_skin_color__cache[30]
-#define BUTTONBAR_BUTTON_COLOR    mc_skin_color__cache[31]
+#define BUTTONBAR_HOTKEY_COLOR    mc_skin_color__cache[29]
+#define BUTTONBAR_BUTTON_COLOR    mc_skin_color__cache[30]
 
-#define STATUSBAR_COLOR           mc_skin_color__cache[32]
+#define STATUSBAR_COLOR           mc_skin_color__cache[31]
 
 /*
  * This should be selectable independently. Default has to be black background
  * foreground does not matter at all.
  */
-#define GAUGE_COLOR               mc_skin_color__cache[33]
-#define INPUT_COLOR               mc_skin_color__cache[34]
-#define INPUT_UNCHANGED_COLOR     mc_skin_color__cache[35]
-#define INPUT_MARK_COLOR          mc_skin_color__cache[36]
-#define INPUT_HISTORY_COLOR       mc_skin_color__cache[37]
-#define COMMAND_HISTORY_COLOR     mc_skin_color__cache[38]
-
-#define HELP_NORMAL_COLOR         mc_skin_color__cache[39]
-#define HELP_ITALIC_COLOR         mc_skin_color__cache[40]
-#define HELP_BOLD_COLOR           mc_skin_color__cache[41]
-#define HELP_LINK_COLOR           mc_skin_color__cache[42]
-#define HELP_SLINK_COLOR          mc_skin_color__cache[43]
-#define HELP_TITLE_COLOR          mc_skin_color__cache[44]
-
-
-#define VIEW_NORMAL_COLOR         mc_skin_color__cache[45]
-#define VIEW_BOLD_COLOR           mc_skin_color__cache[46]
-#define VIEW_UNDERLINED_COLOR     mc_skin_color__cache[47]
-#define VIEW_SELECTED_COLOR       mc_skin_color__cache[48]
+#define GAUGE_COLOR               mc_skin_color__cache[32]
+#define INPUT_COLOR               mc_skin_color__cache[33]
+#define INPUT_UNCHANGED_COLOR     mc_skin_color__cache[34]
+#define INPUT_MARK_COLOR          mc_skin_color__cache[35]
+#define INPUT_HISTORY_COLOR       mc_skin_color__cache[36]
+#define COMMAND_HISTORY_COLOR     mc_skin_color__cache[37]
+
+#define HELP_NORMAL_COLOR         mc_skin_color__cache[38]
+#define HELP_ITALIC_COLOR         mc_skin_color__cache[39]
+#define HELP_BOLD_COLOR           mc_skin_color__cache[40]
+#define HELP_LINK_COLOR           mc_skin_color__cache[41]
+#define HELP_SLINK_COLOR          mc_skin_color__cache[42]
+#define HELP_TITLE_COLOR          mc_skin_color__cache[43]
+
+
+#define VIEW_NORMAL_COLOR         mc_skin_color__cache[44]
+#define VIEW_BOLD_COLOR           mc_skin_color__cache[45]
+#define VIEW_UNDERLINED_COLOR     mc_skin_color__cache[46]
+#define VIEW_SELECTED_COLOR       mc_skin_color__cache[47]
 
 /*
  * editor colors - only 4 for normal, search->found, select, and whitespace
  * respectively
  * Last is defined to view color.
  */
-#define EDITOR_NORMAL_COLOR       mc_skin_color__cache[49]
-#define EDITOR_BOLD_COLOR         mc_skin_color__cache[50]
-#define EDITOR_MARKED_COLOR       mc_skin_color__cache[51]
-#define EDITOR_WHITESPACE_COLOR   mc_skin_color__cache[52]
-#define EDITOR_RIGHT_MARGIN_COLOR mc_skin_color__cache[53]
-#define EDITOR_BACKGROUND         mc_skin_color__cache[54]
-#define EDITOR_FRAME              mc_skin_color__cache[55]
-#define EDITOR_FRAME_ACTIVE       mc_skin_color__cache[56]
-#define EDITOR_FRAME_DRAG         mc_skin_color__cache[57]
+#define EDITOR_NORMAL_COLOR       mc_skin_color__cache[48]
+#define EDITOR_BOLD_COLOR         mc_skin_color__cache[49]
+#define EDITOR_MARKED_COLOR       mc_skin_color__cache[50]
+#define EDITOR_WHITESPACE_COLOR   mc_skin_color__cache[51]
+#define EDITOR_RIGHT_MARGIN_COLOR mc_skin_color__cache[52]
+#define EDITOR_BACKGROUND         mc_skin_color__cache[53]
+#define EDITOR_FRAME              mc_skin_color__cache[54]
+#define EDITOR_FRAME_ACTIVE       mc_skin_color__cache[55]
+#define EDITOR_FRAME_DRAG         mc_skin_color__cache[56]
 /* color of left 8 char status per line */
-#define LINE_STATE_COLOR          mc_skin_color__cache[58]
-#define BOOK_MARK_COLOR           mc_skin_color__cache[59]
-#define BOOK_MARK_FOUND_COLOR     mc_skin_color__cache[60]
+#define LINE_STATE_COLOR          mc_skin_color__cache[57]
+#define BOOK_MARK_COLOR           mc_skin_color__cache[58]
+#define BOOK_MARK_FOUND_COLOR     mc_skin_color__cache[59]
 
 /* Diff colors */
-#define DFF_ADD_COLOR             mc_skin_color__cache[61]
-#define DFF_CHG_COLOR             mc_skin_color__cache[62]
-#define DFF_CHH_COLOR             mc_skin_color__cache[63]
-#define DFF_CHD_COLOR             mc_skin_color__cache[64]
-#define DFF_DEL_COLOR             mc_skin_color__cache[65]
-#define DFF_ERROR_COLOR           mc_skin_color__cache[66]
+#define DFF_ADD_COLOR             mc_skin_color__cache[60]
+#define DFF_CHG_COLOR             mc_skin_color__cache[61]
+#define DFF_CHH_COLOR             mc_skin_color__cache[62]
+#define DFF_CHD_COLOR             mc_skin_color__cache[63]
+#define DFF_DEL_COLOR             mc_skin_color__cache[64]
+#define DFF_ERROR_COLOR           mc_skin_color__cache[65]
 
-#define MC_SKIN_COLOR_CACHE_COUNT 67
+#define MC_SKIN_COLOR_CACHE_COUNT 66
 
 /*** enums ***************************************************************************************/
 
diff -Nuar mc-4.8.26-orig/lib/tty/tty-internal.h mc-4.8.26/lib/tty/tty-internal.h
--- mc-4.8.26-orig/lib/tty/tty-internal.h	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/tty/tty-internal.h	2021-02-13 11:01:18.947534027 +0000
@@ -42,8 +42,6 @@
 void tty_init_xterm_support (gboolean is_xterm);
 int tty_lowlevel_getch (void);
 
-void tty_colorize_area (int y, int x, int rows, int cols, int color);
-
 /*** inline functions ****************************************************************************/
 
 #endif /* MC_TTY_INTERNAL_H */
diff -Nuar mc-4.8.26-orig/lib/tty/tty-ncurses.c mc-4.8.26/lib/tty/tty-ncurses.c
--- mc-4.8.26-orig/lib/tty/tty-ncurses.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/tty/tty-ncurses.c	2021-02-13 11:03:31.439353557 +0000
@@ -48,7 +48,6 @@
 
 #include "tty-internal.h"       /* mc_tty_normalize_from_utf8() */
 #include "tty.h"
-#include "color.h"              /* tty_setcolor */
 #include "color-internal.h"
 #include "key.h"
 #include "mouse.h"
@@ -121,44 +120,6 @@
 }
 
 /* --------------------------------------------------------------------------------------------- */
-
-/**
- * Get visible part of area.
- *
- * @returns TRUE if any part of area is in screen bounds, FALSE otherwise.
- */
-static gboolean
-tty_clip (int *y, int *x, int *rows, int *cols)
-{
-    if (*y < 0)
-    {
-        *rows += *y;
-
-        if (*rows <= 0)
-            return FALSE;
-
-        *y = 0;
-    }
-
-    if (*x < 0)
-    {
-        *cols += *x;
-
-        if (*cols <= 0)
-            return FALSE;
-
-        *x = 0;
-    }
-
-    if (*y + *rows > LINES)
-        *rows = LINES - *y;
-    if (*x + *cols > COLS)
-        *cols = COLS - *x;
-
-    return TRUE;
-}
-
-/* --------------------------------------------------------------------------------------------- */
 /*** public functions ****************************************************************************/
 /* --------------------------------------------------------------------------------------------- */
 
@@ -533,51 +494,41 @@
 {
     int i;
 
-    if (!tty_clip (&y, &x, &rows, &cols))
-        return;
-
-    for (i = 0; i < rows; i++)
+    if (y < 0)
     {
-        move (y + i, x);
-        hline (ch, cols);
-    }
+        rows += y;
 
-    move (y, x);
+        if (rows <= 0)
+            return;
 
-    mc_curs_row = y;
-    mc_curs_col = x;
-}
+        y = 0;
+    }
 
-/* --------------------------------------------------------------------------------------------- */
+    if (x < 0)
+    {
+        cols += x;
 
-void
-tty_colorize_area (int y, int x, int rows, int cols, int color)
-{
-    cchar_t *ctext;
-    wchar_t wch[10];            /* TODO not sure if the length is correct */
-    attr_t attrs;
-    short color_pair;
+        if (cols <= 0)
+            return;
 
-    if (!use_colors || !tty_clip (&y, &x, &rows, &cols))
-        return;
+        x = 0;
+    }
 
-    tty_setcolor (color);
-    ctext = g_malloc (sizeof (cchar_t) * (cols + 1));
+    if (y + rows > LINES)
+        rows = LINES - y;
+    if (x + cols > COLS)
+        cols = COLS - x;
 
-    for (int row = 0; row < rows; row++)
+    for (i = 0; i < rows; i++)
     {
-        mvin_wchnstr (y + row, x, ctext, cols);
-
-        for (int col = 0; col < cols; col++)
-        {
-            getcchar (&ctext[col], wch, &attrs, &color_pair, NULL);
-            setcchar (&ctext[col], wch, attrs, color, NULL);
-        }
-
-        mvadd_wchnstr (y + row, x, ctext, cols);
+        move (y + i, x);
+        hline (ch, cols);
     }
 
-    g_free (ctext);
+    move (y, x);
+
+    mc_curs_row = y;
+    mc_curs_col = x;
 }
 
 /* --------------------------------------------------------------------------------------------- */
diff -Nuar mc-4.8.26-orig/lib/tty/tty-ncurses.c.orig mc-4.8.26/lib/tty/tty-ncurses.c.orig
--- mc-4.8.26-orig/lib/tty/tty-ncurses.c.orig	1970-01-01 00:00:00.000000000 +0000
+++ mc-4.8.26/lib/tty/tty-ncurses.c.orig	2021-01-10 11:50:16.000000000 +0000
@@ -0,0 +1,756 @@
+/*
+   Interface to the terminal controlling library.
+   Ncurses wrapper.
+
+   Copyright (C) 2005-2020
+   Free Software Foundation, Inc.
+
+   Written by:
+   Andrew Borodin <aborodin@vmail.ru>, 2009.
+   Ilia Maslakov <il.smind@gmail.com>, 2009.
+
+   This file is part of the Midnight Commander.
+
+   The Midnight Commander is free software: you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation, either version 3 of the License,
+   or (at your option) any later version.
+
+   The Midnight Commander is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file
+ *  \brief Source: NCurses-based tty layer of Midnight-commander
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <signal.h>
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+#include <termios.h>
+
+#include "lib/global.h"
+#include "lib/strutil.h"        /* str_term_form */
+
+#ifndef WANT_TERM_H
+#define WANT_TERM_H
+#endif
+
+#include "tty-internal.h"       /* mc_tty_normalize_from_utf8() */
+#include "tty.h"
+#include "color.h"              /* tty_setcolor */
+#include "color-internal.h"
+#include "key.h"
+#include "mouse.h"
+#include "win.h"
+
+/* include at last !!! */
+#ifdef WANT_TERM_H
+#ifdef HAVE_NCURSES_TERM_H
+#include <ncurses/term.h>
+#else
+#include <term.h>
+#endif /* HAVE_NCURSES_TERM_H */
+#endif /* WANT_TERM_H */
+
+/*** global variables ****************************************************************************/
+
+/*** file scope macro definitions ****************************************************************/
+
+#if !defined(CTRL)
+#define CTRL(x) ((x) & 0x1f)
+#endif
+
+#define yx_in_screen(y, x) \
+    (y >= 0 && y < LINES && x >= 0 && x < COLS)
+
+/*** global variables ****************************************************************************/
+
+/*** file scope type declarations ****************************************************************/
+
+/*** file scope variables ************************************************************************/
+
+/* ncurses supports cursor positions only within window */
+/* We use our own cursor coordinates to support partially visible widgets */
+static int mc_curs_row, mc_curs_col;
+
+/*** file scope functions ************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+/* --------------------------------------------------------------------------------------------- */
+
+static void
+tty_setup_sigwinch (void (*handler) (int))
+{
+#if (NCURSES_VERSION_MAJOR >= 4) && defined (SIGWINCH)
+    struct sigaction act, oact;
+
+    memset (&act, 0, sizeof (act));
+    act.sa_handler = handler;
+    sigemptyset (&act.sa_mask);
+#ifdef SA_RESTART
+    act.sa_flags = SA_RESTART;
+#endif /* SA_RESTART */
+    sigaction (SIGWINCH, &act, &oact);
+#endif /* SIGWINCH */
+
+    tty_create_winch_pipe ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static void
+sigwinch_handler (int dummy)
+{
+    ssize_t n = 0;
+
+    (void) dummy;
+
+    n = write (sigwinch_pipe[1], "", 1);
+    (void) n;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+/**
+ * Get visible part of area.
+ *
+ * @returns TRUE if any part of area is in screen bounds, FALSE otherwise.
+ */
+static gboolean
+tty_clip (int *y, int *x, int *rows, int *cols)
+{
+    if (*y < 0)
+    {
+        *rows += *y;
+
+        if (*rows <= 0)
+            return FALSE;
+
+        *y = 0;
+    }
+
+    if (*x < 0)
+    {
+        *cols += *x;
+
+        if (*cols <= 0)
+            return FALSE;
+
+        *x = 0;
+    }
+
+    if (*y + *rows > LINES)
+        *rows = LINES - *y;
+    if (*x + *cols > COLS)
+        *cols = COLS - *x;
+
+    return TRUE;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+/*** public functions ****************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+int
+mc_tty_normalize_lines_char (const char *ch)
+{
+    char *str2;
+    int res;
+
+    struct mc_tty_lines_struct
+    {
+        const char *line;
+        int line_code;
+    } const lines_codes[] = {
+        {"\342\224\230", ACS_LRCORNER}, /* ┌ */
+        {"\342\224\224", ACS_LLCORNER}, /* └ */
+        {"\342\224\220", ACS_URCORNER}, /* ┐ */
+        {"\342\224\214", ACS_ULCORNER}, /* ┘ */
+        {"\342\224\234", ACS_LTEE},     /* ├ */
+        {"\342\224\244", ACS_RTEE},     /* ┤ */
+        {"\342\224\254", ACS_TTEE},     /* ┬ */
+        {"\342\224\264", ACS_BTEE},     /* ┴ */
+        {"\342\224\200", ACS_HLINE},    /* ─ */
+        {"\342\224\202", ACS_VLINE},    /* │ */
+        {"\342\224\274", ACS_PLUS},     /* ┼ */
+
+        {"\342\225\235", ACS_LRCORNER | A_BOLD},        /* ╔ */
+        {"\342\225\232", ACS_LLCORNER | A_BOLD},        /* ╚ */
+        {"\342\225\227", ACS_URCORNER | A_BOLD},        /* ╗ */
+        {"\342\225\224", ACS_ULCORNER | A_BOLD},        /* ╝ */
+        {"\342\225\237", ACS_LTEE | A_BOLD},    /* ╟ */
+        {"\342\225\242", ACS_RTEE | A_BOLD},    /* ╢ */
+        {"\342\225\244", ACS_TTEE | A_BOLD},    /* ╤ */
+        {"\342\225\247", ACS_BTEE | A_BOLD},    /* ╧ */
+        {"\342\225\220", ACS_HLINE | A_BOLD},   /* ═ */
+        {"\342\225\221", ACS_VLINE | A_BOLD},   /* ║ */
+
+        {NULL, 0}
+    };
+
+    if (ch == NULL)
+        return (int) ' ';
+
+    for (res = 0; lines_codes[res].line; res++)
+    {
+        if (strcmp (ch, lines_codes[res].line) == 0)
+            return lines_codes[res].line_code;
+    }
+
+    str2 = mc_tty_normalize_from_utf8 (ch);
+    res = g_utf8_get_char_validated (str2, -1);
+
+    if (res < 0)
+        res = (unsigned char) str2[0];
+    g_free (str2);
+
+    return res;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_init (gboolean mouse_enable, gboolean is_xterm)
+{
+    struct termios mode;
+
+    initscr ();
+
+#ifdef HAVE_ESCDELAY
+    /*
+     * If ncurses exports the ESCDELAY variable, it should be set to
+     * a low value, or you'll experience a delay in processing escape
+     * sequences that are recognized by mc (e.g. Esc-Esc).  On the other
+     * hand, making ESCDELAY too small can result in some sequences
+     * (e.g. cursor arrows) being reported as separate keys under heavy
+     * processor load, and this can be a problem if mc hasn't learned
+     * them in the "Learn Keys" dialog.  The value is in milliseconds.
+     */
+    ESCDELAY = 200;
+#endif /* HAVE_ESCDELAY */
+
+    tcgetattr (STDIN_FILENO, &mode);
+    /* use Ctrl-g to generate SIGINT */
+    mode.c_cc[VINTR] = CTRL ('g');      /* ^g */
+    /* disable SIGQUIT to allow use Ctrl-\ key */
+    mode.c_cc[VQUIT] = NULL_VALUE;
+    tcsetattr (STDIN_FILENO, TCSANOW, &mode);
+
+    /* curses remembers the "in-program" modes after this call */
+    def_prog_mode ();
+
+    tty_start_interrupt_key ();
+
+    if (!mouse_enable)
+        use_mouse_p = MOUSE_DISABLED;
+    tty_init_xterm_support (is_xterm);  /* do it before tty_enter_ca_mode() call */
+    tty_enter_ca_mode ();
+    tty_raw_mode ();
+    noecho ();
+    keypad (stdscr, TRUE);
+    nodelay (stdscr, FALSE);
+
+    tty_setup_sigwinch (sigwinch_handler);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_shutdown (void)
+{
+    tty_destroy_winch_pipe ();
+    tty_reset_shell_mode ();
+    tty_noraw_mode ();
+    tty_keypad (FALSE);
+    tty_reset_screen ();
+    tty_exit_ca_mode ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_enter_ca_mode (void)
+{
+    if (mc_global.tty.xterm_flag && smcup != NULL)
+    {
+        fprintf (stdout, /* ESC_STR ")0" */ ESC_STR "7" ESC_STR "[?47h");
+        fflush (stdout);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_exit_ca_mode (void)
+{
+    if (mc_global.tty.xterm_flag && rmcup != NULL)
+    {
+        fprintf (stdout, ESC_STR "[?47l" ESC_STR "8" ESC_STR "[m");
+        fflush (stdout);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_change_screen_size (void)
+{
+#if defined(TIOCGWINSZ) && NCURSES_VERSION_MAJOR >= 4
+    struct winsize winsz;
+
+    winsz.ws_col = winsz.ws_row = 0;
+
+#ifndef NCURSES_VERSION
+    tty_noraw_mode ();
+    tty_reset_screen ();
+#endif
+
+    /* Ioctl on the STDIN_FILENO */
+    ioctl (fileno (stdout), TIOCGWINSZ, &winsz);
+    if (winsz.ws_col != 0 && winsz.ws_row != 0)
+    {
+#if defined(NCURSES_VERSION) && defined(HAVE_RESIZETERM)
+        resizeterm (winsz.ws_row, winsz.ws_col);
+        clearok (stdscr, TRUE); /* sigwinch's should use a semaphore! */
+#else
+        COLS = winsz.ws_col;
+        LINES = winsz.ws_row;
+#endif
+    }
+#endif /* defined(TIOCGWINSZ) || NCURSES_VERSION_MAJOR >= 4 */
+
+#ifdef ENABLE_SUBSHELL
+    if (mc_global.tty.use_subshell)
+        tty_resize (mc_global.tty.subshell_pty);
+#endif
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_reset_prog_mode (void)
+{
+    reset_prog_mode ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_reset_shell_mode (void)
+{
+    reset_shell_mode ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_raw_mode (void)
+{
+    raw ();                     /* FIXME: uneeded? */
+    cbreak ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_noraw_mode (void)
+{
+    nocbreak ();                /* FIXME: unneeded? */
+    noraw ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_noecho (void)
+{
+    noecho ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+int
+tty_flush_input (void)
+{
+    return flushinp ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_keypad (gboolean set)
+{
+    keypad (stdscr, (bool) set);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_nodelay (gboolean set)
+{
+    nodelay (stdscr, (bool) set);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+int
+tty_baudrate (void)
+{
+    return baudrate ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+int
+tty_lowlevel_getch (void)
+{
+    return getch ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+int
+tty_reset_screen (void)
+{
+    return endwin ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_touch_screen (void)
+{
+    touchwin (stdscr);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_gotoyx (int y, int x)
+{
+    mc_curs_row = y;
+    mc_curs_col = x;
+
+    if (y < 0)
+        y = 0;
+    if (y >= LINES)
+        y = LINES - 1;
+
+    if (x < 0)
+        x = 0;
+    if (x >= COLS)
+        x = COLS - 1;
+
+    move (y, x);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_getyx (int *py, int *px)
+{
+    *py = mc_curs_row;
+    *px = mc_curs_col;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_draw_hline (int y, int x, int ch, int len)
+{
+    int x1;
+
+    if (y < 0 || y >= LINES || x >= COLS)
+        return;
+
+    x1 = x;
+
+    if (x < 0)
+    {
+        len += x;
+        if (len <= 0)
+            return;
+        x = 0;
+    }
+
+    if ((chtype) ch == ACS_HLINE)
+        ch = mc_tty_frm[MC_TTY_FRM_HORIZ];
+
+    move (y, x);
+    hline (ch, len);
+    move (y, x1);
+
+    mc_curs_row = y;
+    mc_curs_col = x1;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_draw_vline (int y, int x, int ch, int len)
+{
+    int y1;
+
+    if (x < 0 || x >= COLS || y >= LINES)
+        return;
+
+    y1 = y;
+
+    if (y < 0)
+    {
+        len += y;
+        if (len <= 0)
+            return;
+        y = 0;
+    }
+
+    if ((chtype) ch == ACS_VLINE)
+        ch = mc_tty_frm[MC_TTY_FRM_VERT];
+
+    move (y, x);
+    vline (ch, len);
+    move (y1, x);
+
+    mc_curs_row = y1;
+    mc_curs_col = x;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_fill_region (int y, int x, int rows, int cols, unsigned char ch)
+{
+    int i;
+
+    if (!tty_clip (&y, &x, &rows, &cols))
+        return;
+
+    for (i = 0; i < rows; i++)
+    {
+        move (y + i, x);
+        hline (ch, cols);
+    }
+
+    move (y, x);
+
+    mc_curs_row = y;
+    mc_curs_col = x;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_colorize_area (int y, int x, int rows, int cols, int color)
+{
+    cchar_t *ctext;
+    wchar_t wch[10];            /* TODO not sure if the length is correct */
+    attr_t attrs;
+    short color_pair;
+
+    if (!use_colors || !tty_clip (&y, &x, &rows, &cols))
+        return;
+
+    tty_setcolor (color);
+    ctext = g_malloc (sizeof (cchar_t) * (cols + 1));
+
+    for (int row = 0; row < rows; row++)
+    {
+        mvin_wchnstr (y + row, x, ctext, cols);
+
+        for (int col = 0; col < cols; col++)
+        {
+            getcchar (&ctext[col], wch, &attrs, &color_pair, NULL);
+            setcchar (&ctext[col], wch, attrs, color, NULL);
+        }
+
+        mvadd_wchnstr (y + row, x, ctext, cols);
+    }
+
+    g_free (ctext);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_set_alt_charset (gboolean alt_charset)
+{
+    (void) alt_charset;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_display_8bit (gboolean what)
+{
+    meta (stdscr, (int) what);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_print_char (int c)
+{
+    if (yx_in_screen (mc_curs_row, mc_curs_col))
+        addch (c);
+    mc_curs_col++;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_print_anychar (int c)
+{
+    if (mc_global.utf8_display || c > 255)
+    {
+        int res;
+        unsigned char str[UTF8_CHAR_LEN + 1];
+
+        res = g_unichar_to_utf8 (c, (char *) str);
+        if (res == 0)
+        {
+            if (yx_in_screen (mc_curs_row, mc_curs_col))
+                addch ('.');
+            mc_curs_col++;
+        }
+        else
+        {
+            const char *s;
+
+            str[res] = '\0';
+            s = str_term_form ((char *) str);
+
+            if (yx_in_screen (mc_curs_row, mc_curs_col))
+                addstr (s);
+
+            if (g_unichar_iswide (c))
+                mc_curs_col += 2;
+            else if (!g_unichar_iszerowidth (c))
+                mc_curs_col++;
+        }
+    }
+    else
+    {
+        if (yx_in_screen (mc_curs_row, mc_curs_col))
+            addch (c);
+        mc_curs_col++;
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_print_alt_char (int c, gboolean single)
+{
+    if (yx_in_screen (mc_curs_row, mc_curs_col))
+    {
+        if ((chtype) c == ACS_VLINE)
+            c = mc_tty_frm[single ? MC_TTY_FRM_VERT : MC_TTY_FRM_DVERT];
+        else if ((chtype) c == ACS_HLINE)
+            c = mc_tty_frm[single ? MC_TTY_FRM_HORIZ : MC_TTY_FRM_DHORIZ];
+        else if ((chtype) c == ACS_LTEE)
+            c = mc_tty_frm[single ? MC_TTY_FRM_LEFTMIDDLE : MC_TTY_FRM_DLEFTMIDDLE];
+        else if ((chtype) c == ACS_RTEE)
+            c = mc_tty_frm[single ? MC_TTY_FRM_RIGHTMIDDLE : MC_TTY_FRM_DRIGHTMIDDLE];
+        else if ((chtype) c == ACS_ULCORNER)
+            c = mc_tty_frm[single ? MC_TTY_FRM_LEFTTOP : MC_TTY_FRM_DLEFTTOP];
+        else if ((chtype) c == ACS_LLCORNER)
+            c = mc_tty_frm[single ? MC_TTY_FRM_LEFTBOTTOM : MC_TTY_FRM_DLEFTBOTTOM];
+        else if ((chtype) c == ACS_URCORNER)
+            c = mc_tty_frm[single ? MC_TTY_FRM_RIGHTTOP : MC_TTY_FRM_DRIGHTTOP];
+        else if ((chtype) c == ACS_LRCORNER)
+            c = mc_tty_frm[single ? MC_TTY_FRM_RIGHTBOTTOM : MC_TTY_FRM_DRIGHTBOTTOM];
+        else if ((chtype) c == ACS_PLUS)
+            c = mc_tty_frm[MC_TTY_FRM_CROSS];
+
+        addch (c);
+    }
+
+    mc_curs_col++;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_print_string (const char *s)
+{
+    int len;
+    int start = 0;
+
+    s = str_term_form (s);
+    len = str_term_width1 (s);
+
+    /* line is upper or below the screen or entire line is before or after screen */
+    if (mc_curs_row < 0 || mc_curs_row >= LINES || mc_curs_col + len <= 0 || mc_curs_col >= COLS)
+    {
+        mc_curs_col += len;
+        return;
+    }
+
+    /* skip invisible left part */
+    if (mc_curs_col < 0)
+    {
+        start = -mc_curs_col;
+        len += mc_curs_col;
+        mc_curs_col = 0;
+    }
+
+    mc_curs_col += len;
+    if (mc_curs_col >= COLS)
+        len = COLS - (mc_curs_col - len);
+
+    addstr (str_term_substring (s, start, len));
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_printf (const char *fmt, ...)
+{
+    va_list args;
+    char buf[BUF_1K];           /* FIXME: is it enough? */
+
+    va_start (args, fmt);
+    g_vsnprintf (buf, sizeof (buf), fmt, args);
+    va_end (args);
+    tty_print_string (buf);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+char *
+tty_tgetstr (const char *cap)
+{
+    char *unused = NULL;
+
+    return tgetstr ((NCURSES_CONST char *) cap, &unused);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_refresh (void)
+{
+    refresh ();
+    doupdate ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_beep (void)
+{
+    beep ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
diff -Nuar mc-4.8.26-orig/lib/tty/tty-ncurses.c.rej mc-4.8.26/lib/tty/tty-ncurses.c.rej
--- mc-4.8.26-orig/lib/tty/tty-ncurses.c.rej	1970-01-01 00:00:00.000000000 +0000
+++ mc-4.8.26/lib/tty/tty-ncurses.c.rej	2021-02-13 11:01:18.950867406 +0000
@@ -0,0 +1,41 @@
+--- lib/tty/tty-ncurses.c
++++ lib/tty/tty-ncurses.c
+@@ -533,38 +516,6 @@ tty_fill_region (int y, int x, int rows, int cols, unsigned char ch)
+ 
+ /* --------------------------------------------------------------------------------------------- */
+ 
+-void
+-tty_colorize_area (int y, int x, int rows, int cols, int color)
+-{
+-    cchar_t *ctext;
+-    wchar_t wch[10];   /* TODO not sure if the length is correct */
+-    attr_t attrs;
+-    short color_pair;
+-
+-    if (!use_colors || !tty_clip (&y, &x, &rows, &cols))
+-        return;
+-
+-    tty_setcolor (color);
+-    ctext = g_malloc (sizeof (cchar_t) * (cols + 1));
+-
+-    for (int row = 0; row < rows; row++)
+-    {
+-        mvin_wchnstr (y + row, x, ctext, cols);
+-
+-        for (int col = 0; col < cols; col++)
+-        {
+-            getcchar (&ctext[col], wch, &attrs, &color_pair, NULL);
+-            setcchar (&ctext[col], wch, attrs, color, NULL);
+-        }
+-
+-        mvadd_wchnstr (y + row, x, ctext, cols);
+-    }
+-
+-    g_free (ctext);
+-}
+-
+-/* --------------------------------------------------------------------------------------------- */
+-
+ void
+ tty_set_alt_charset (gboolean alt_charset)
+ {
diff -Nuar mc-4.8.26-orig/lib/tty/tty-slang.c mc-4.8.26/lib/tty/tty-slang.c
--- mc-4.8.26-orig/lib/tty/tty-slang.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/tty/tty-slang.c	2021-02-13 11:01:18.950867406 +0000
@@ -623,15 +623,6 @@
 /* --------------------------------------------------------------------------------------------- */
 
 void
-tty_colorize_area (int y, int x, int rows, int cols, int color)
-{
-    if (use_colors)
-        SLsmg_set_color_in_region (color, y, x, rows, cols);
-}
-
-/* --------------------------------------------------------------------------------------------- */
-
-void
 tty_set_alt_charset (gboolean alt_charset)
 {
     SLsmg_set_char_set ((int) alt_charset);
diff -Nuar mc-4.8.26-orig/lib/tty/tty.c mc-4.8.26/lib/tty/tty.c
--- mc-4.8.26-orig/lib/tty/tty.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/tty/tty.c	2021-02-13 11:01:18.950867406 +0000
@@ -265,17 +265,6 @@
 
 /* --------------------------------------------------------------------------------------------- */
 
-void
-tty_draw_box_shadow (int y, int x, int rows, int cols, int shadow_color)
-{
-    /* draw right shadow */
-    tty_colorize_area (y + 1, x + cols, rows - 1, 2, shadow_color);
-    /* draw bottom shadow */
-    tty_colorize_area (y + rows, x + 2, 1, cols, shadow_color);
-}
-
-/* --------------------------------------------------------------------------------------------- */
-
 char *
 mc_tty_normalize_from_utf8 (const char *str)
 {
diff -Nuar mc-4.8.26-orig/lib/tty/tty.c.orig mc-4.8.26/lib/tty/tty.c.orig
--- mc-4.8.26-orig/lib/tty/tty.c.orig	1970-01-01 00:00:00.000000000 +0000
+++ mc-4.8.26/lib/tty/tty.c.orig	2021-01-10 11:50:16.000000000 +0000
@@ -0,0 +1,402 @@
+/*
+   Interface to the terminal controlling library.
+
+   Copyright (C) 2005-2020
+   Free Software Foundation, Inc.
+
+   Written by:
+   Roland Illig <roland.illig@gmx.de>, 2005.
+   Andrew Borodin <aborodin@vmail.ru>, 2009.
+
+   This file is part of the Midnight Commander.
+
+   The Midnight Commander is free software: you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation, either version 3 of the License,
+   or (at your option) any later version.
+
+   The Midnight Commander is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file tty.c
+ *  \brief Source: %interface to the terminal controlling library
+ */
+
+#include <config.h>
+
+#include <errno.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>             /* memset() */
+
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#else
+#include <sys/time.h>
+#include <sys/types.h>
+#endif
+#include <unistd.h>             /* exit() */
+
+#ifdef HAVE_SYS_IOCTL_H
+#include <sys/ioctl.h>
+#endif
+
+/* In some systems (like Solaris 11.4 SPARC), TIOCSWINSZ is defined in termios.h */
+#include <termios.h>
+
+#include "lib/global.h"
+#include "lib/strutil.h"
+
+#include "tty.h"
+#include "tty-internal.h"
+#include "color.h"              /* tty_set_normal_attrs() */
+#include "mouse.h"              /* use_mouse_p */
+#include "win.h"
+
+/*** global variables ****************************************************************************/
+
+int mc_tty_frm[MC_TTY_FRM_MAX];
+
+/*** file scope macro definitions ****************************************************************/
+
+/*** file scope type declarations ****************************************************************/
+
+/*** file scope variables ************************************************************************/
+
+static SIG_ATOMIC_VOLATILE_T got_interrupt = 0;
+
+/*** file scope functions ************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+static void
+sigintr_handler (int signo)
+{
+    (void) &signo;
+    got_interrupt = 1;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+/*** public functions ****************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+/**
+ * Check terminal type. If $TERM is not set or value is empty, mc finishes with EXIT_FAILURE.
+ *
+ * @param force_xterm Set forced the XTerm type
+ *
+ * @return true if @param force_xterm is true or value of $TERM is one of term*, konsole*
+ *              rxvt*, Eterm or dtterm
+ */
+gboolean
+tty_check_term (gboolean force_xterm)
+{
+    const char *termvalue;
+    const char *xdisplay;
+
+    termvalue = getenv ("TERM");
+    if (termvalue == NULL || *termvalue == '\0')
+    {
+        fputs (_("The TERM environment variable is unset!\n"), stderr);
+        exit (EXIT_FAILURE);
+    }
+
+    xdisplay = getenv ("DISPLAY");
+    if (xdisplay != NULL && *xdisplay == '\0')
+        xdisplay = NULL;
+
+    return force_xterm || strncmp (termvalue, "xterm", 5) == 0
+        || strncmp (termvalue, "konsole", 7) == 0
+        || strncmp (termvalue, "rxvt", 4) == 0
+        || strcmp (termvalue, "Eterm") == 0
+        || strcmp (termvalue, "dtterm") == 0
+        || (strncmp (termvalue, "screen", 6) == 0 && xdisplay != NULL);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+extern void
+tty_start_interrupt_key (void)
+{
+    struct sigaction act;
+
+    memset (&act, 0, sizeof (act));
+    act.sa_handler = sigintr_handler;
+    sigemptyset (&act.sa_mask);
+#ifdef SA_RESTART
+    act.sa_flags = SA_RESTART;
+#endif /* SA_RESTART */
+    sigaction (SIGINT, &act, NULL);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+extern void
+tty_enable_interrupt_key (void)
+{
+    struct sigaction act;
+
+    memset (&act, 0, sizeof (act));
+    act.sa_handler = sigintr_handler;
+    sigemptyset (&act.sa_mask);
+    sigaction (SIGINT, &act, NULL);
+    got_interrupt = 0;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+extern void
+tty_disable_interrupt_key (void)
+{
+    struct sigaction act;
+
+    memset (&act, 0, sizeof (act));
+    act.sa_handler = SIG_IGN;
+    sigemptyset (&act.sa_mask);
+    sigaction (SIGINT, &act, NULL);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+extern gboolean
+tty_got_interrupt (void)
+{
+    gboolean rv;
+
+    rv = (got_interrupt != 0);
+    got_interrupt = 0;
+    return rv;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+gboolean
+tty_got_winch (void)
+{
+    fd_set fdset;
+    /* *INDENT-OFF* */
+    /* instant timeout */
+    struct timeval timeout = { .tv_sec = 0, .tv_usec = 0 };
+    /* *INDENT-ON* */
+    int ok;
+
+    FD_ZERO (&fdset);
+    FD_SET (sigwinch_pipe[0], &fdset);
+
+    while ((ok = select (sigwinch_pipe[0] + 1, &fdset, NULL, NULL, &timeout)) < 0)
+        if (errno != EINTR)
+        {
+            perror (_("Cannot check SIGWINCH pipe"));
+            exit (EXIT_FAILURE);
+        }
+
+    return (ok != 0 && FD_ISSET (sigwinch_pipe[0], &fdset));
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_flush_winch (void)
+{
+    ssize_t n;
+
+    /* merge all SIGWINCH events raised to this moment */
+    do
+    {
+        char x[16];
+
+        /* read multiple events at a time  */
+        n = read (sigwinch_pipe[0], &x, sizeof (x));
+    }
+    while (n > 0 || (n == -1 && errno == EINTR));
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_print_one_hline (gboolean single)
+{
+    tty_print_alt_char (ACS_HLINE, single);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_print_one_vline (gboolean single)
+{
+    tty_print_alt_char (ACS_VLINE, single);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_draw_box (int y, int x, int ys, int xs, gboolean single)
+{
+    int y2, x2;
+
+    if (ys <= 0 || xs <= 0)
+        return;
+
+    ys--;
+    xs--;
+
+    y2 = y + ys;
+    x2 = x + xs;
+
+    tty_draw_vline (y, x, mc_tty_frm[single ? MC_TTY_FRM_VERT : MC_TTY_FRM_DVERT], ys);
+    tty_draw_vline (y, x2, mc_tty_frm[single ? MC_TTY_FRM_VERT : MC_TTY_FRM_DVERT], ys);
+    tty_draw_hline (y, x, mc_tty_frm[single ? MC_TTY_FRM_HORIZ : MC_TTY_FRM_DHORIZ], xs);
+    tty_draw_hline (y2, x, mc_tty_frm[single ? MC_TTY_FRM_HORIZ : MC_TTY_FRM_DHORIZ], xs);
+    tty_gotoyx (y, x);
+    tty_print_alt_char (ACS_ULCORNER, single);
+    tty_gotoyx (y2, x);
+    tty_print_alt_char (ACS_LLCORNER, single);
+    tty_gotoyx (y, x2);
+    tty_print_alt_char (ACS_URCORNER, single);
+    tty_gotoyx (y2, x2);
+    tty_print_alt_char (ACS_LRCORNER, single);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_draw_box_shadow (int y, int x, int rows, int cols, int shadow_color)
+{
+    /* draw right shadow */
+    tty_colorize_area (y + 1, x + cols, rows - 1, 2, shadow_color);
+    /* draw bottom shadow */
+    tty_colorize_area (y + rows, x + 2, 1, cols, shadow_color);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+char *
+mc_tty_normalize_from_utf8 (const char *str)
+{
+    GIConv conv;
+    GString *buffer;
+    const char *_system_codepage = str_detect_termencoding ();
+
+    if (str_isutf8 (_system_codepage))
+        return g_strdup (str);
+
+    conv = g_iconv_open (_system_codepage, "UTF-8");
+    if (conv == INVALID_CONV)
+        return g_strdup (str);
+
+    buffer = g_string_new ("");
+
+    if (str_convert (conv, str, buffer) == ESTR_FAILURE)
+    {
+        g_string_free (buffer, TRUE);
+        str_close_conv (conv);
+        return g_strdup (str);
+    }
+    str_close_conv (conv);
+
+    return g_string_free (buffer, FALSE);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+/** Resize given terminal using TIOCSWINSZ, return ioctl() result */
+int
+tty_resize (int fd)
+{
+#if defined TIOCSWINSZ
+    struct winsize tty_size;
+
+    tty_size.ws_row = LINES;
+    tty_size.ws_col = COLS;
+    tty_size.ws_xpixel = tty_size.ws_ypixel = 0;
+
+    return ioctl (fd, TIOCSWINSZ, &tty_size);
+#else
+    return 0;
+#endif
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+/** Clear screen */
+void
+tty_clear_screen (void)
+{
+    tty_set_normal_attrs ();
+    tty_fill_region (0, 0, LINES, COLS, ' ');
+    tty_refresh ();
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+tty_init_xterm_support (gboolean is_xterm)
+{
+    const char *termvalue;
+
+    termvalue = getenv ("TERM");
+
+    /* Check mouse and ca capabilities */
+    /* terminfo/termcap structures have been already initialized,
+       in slang_init() or/and init_curses()  */
+    /* Check terminfo at first, then check termcap */
+    xmouse_seq = tty_tgetstr ("kmous");
+    if (xmouse_seq == NULL)
+        xmouse_seq = tty_tgetstr ("Km");
+    smcup = tty_tgetstr ("smcup");
+    if (smcup == NULL)
+        smcup = tty_tgetstr ("ti");
+    rmcup = tty_tgetstr ("rmcup");
+    if (rmcup == NULL)
+        rmcup = tty_tgetstr ("te");
+
+    if (strcmp (termvalue, "cygwin") == 0)
+    {
+        is_xterm = TRUE;
+        use_mouse_p = MOUSE_DISABLED;
+    }
+
+    if (is_xterm)
+    {
+        /* Default to the standard xterm sequence */
+        if (xmouse_seq == NULL)
+            xmouse_seq = ESC_STR "[M";
+
+        /* Enable mouse unless explicitly disabled by --nomouse */
+        if (use_mouse_p != MOUSE_DISABLED)
+        {
+            if (mc_global.tty.old_mouse)
+                use_mouse_p = MOUSE_XTERM_NORMAL_TRACKING;
+            else
+            {
+                /* FIXME: this dirty hack to set supported type of tracking the mouse */
+                const char *color_term = getenv ("COLORTERM");
+                if (strncmp (termvalue, "rxvt", 4) == 0 ||
+                    (color_term != NULL && strncmp (color_term, "rxvt", 4) == 0) ||
+                    strcmp (termvalue, "Eterm") == 0)
+                    use_mouse_p = MOUSE_XTERM_NORMAL_TRACKING;
+                else
+                    use_mouse_p = MOUSE_XTERM_BUTTON_EVENT_TRACKING;
+            }
+        }
+    }
+
+    /* There's only one termcap entry "kmous", typically containing "\E[M" or "\E[<".
+     * We need the former in xmouse_seq, the latter in xmouse_extended_seq.
+     * See tickets 2956, 3954, and 4063 for details. */
+    if (xmouse_seq != NULL)
+    {
+        if (strcmp (xmouse_seq, ESC_STR "[<") == 0)
+            xmouse_seq = ESC_STR "[M";
+
+        xmouse_extended_seq = ESC_STR "[<";
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
diff -Nuar mc-4.8.26-orig/lib/tty/tty.h mc-4.8.26/lib/tty/tty.h
--- mc-4.8.26-orig/lib/tty/tty.h	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/tty/tty.h	2021-02-13 11:01:18.954200785 +0000
@@ -126,7 +126,6 @@
 extern void tty_draw_hline (int y, int x, int ch, int len);
 extern void tty_draw_vline (int y, int x, int ch, int len);
 extern void tty_draw_box (int y, int x, int rows, int cols, gboolean single);
-extern void tty_draw_box_shadow (int y, int x, int rows, int cols, int shadow_color);
 extern void tty_fill_region (int y, int x, int rows, int cols, unsigned char ch);
 
 extern int tty_resize (int fd);
diff -Nuar mc-4.8.26-orig/lib/widget/frame.c mc-4.8.26/lib/widget/frame.c
--- mc-4.8.26-orig/lib/widget/frame.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/widget/frame.c	2021-02-13 11:01:18.954200785 +0000
@@ -76,9 +76,6 @@
 
     colors = widget_get_colors (w);
 
-    if (mc_global.tty.shadows)
-        tty_draw_box_shadow (w->y, w->x, w->lines, w->cols, SHADOW_COLOR);
-
     tty_setcolor (colors[FRAME_COLOR_NORMAL]);
     tty_fill_region (w->y, w->x, w->lines, w->cols, ' ');
     tty_draw_box (w->y + d, w->x + d, w->lines - 2 * d, w->cols - 2 * d, f->single);
diff -Nuar mc-4.8.26-orig/lib/widget/menu.c mc-4.8.26/lib/widget/menu.c
--- mc-4.8.26-orig/lib/widget/menu.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/lib/widget/menu.c	2021-02-13 11:01:18.954200785 +0000
@@ -187,10 +187,6 @@
     if (column + menu->max_entry_len + 5 > (gsize) w->cols)
         column = w->cols - menu->max_entry_len - 5;
 
-    if (mc_global.tty.shadows)
-        tty_draw_box_shadow (w->y + 1, w->x + column, count + 2, menu->max_entry_len + 5,
-                             SHADOW_COLOR);
-
     tty_setcolor (MENU_ENTRY_COLOR);
     tty_draw_box (w->y + 1, w->x + column, count + 2, menu->max_entry_len + 5, FALSE);
 
diff -Nuar mc-4.8.26-orig/misc/skins/dark.ini mc-4.8.26/misc/skins/dark.ini
--- mc-4.8.26-orig/misc/skins/dark.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/dark.ini	2021-02-13 11:01:18.954200785 +0000
@@ -39,7 +39,6 @@
     header = yellow;black
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = brightcyan;blue
diff -Nuar mc-4.8.26-orig/misc/skins/darkfar.ini mc-4.8.26/misc/skins/darkfar.ini
--- mc-4.8.26-orig/misc/skins/darkfar.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/darkfar.ini	2021-02-13 11:01:18.954200785 +0000
@@ -39,7 +39,6 @@
     header = yellow;black
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = brightcyan;blue
diff -Nuar mc-4.8.26-orig/misc/skins/default.ini mc-4.8.26/misc/skins/default.ini
--- mc-4.8.26-orig/misc/skins/default.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/default.ini	2021-02-13 11:01:18.954200785 +0000
@@ -39,7 +39,6 @@
     header = yellow;blue
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = black;lightgray
diff -Nuar mc-4.8.26-orig/misc/skins/double-lines.ini mc-4.8.26/misc/skins/double-lines.ini
--- mc-4.8.26-orig/misc/skins/double-lines.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/double-lines.ini	2021-02-13 11:01:18.957534164 +0000
@@ -39,7 +39,6 @@
     header = yellow;blue
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = black;lightgray
diff -Nuar mc-4.8.26-orig/misc/skins/featured-plus.ini mc-4.8.26/misc/skins/featured-plus.ini
--- mc-4.8.26-orig/misc/skins/featured-plus.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/featured-plus.ini	2021-02-13 11:01:18.957534164 +0000
@@ -41,7 +41,6 @@
     header = yellow;blue
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = black;lightgray
diff -Nuar mc-4.8.26-orig/misc/skins/featured.ini mc-4.8.26/misc/skins/featured.ini
--- mc-4.8.26-orig/misc/skins/featured.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/featured.ini	2021-02-13 11:01:18.957534164 +0000
@@ -41,7 +41,6 @@
     header = yellow;blue
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = black;lightgray
diff -Nuar mc-4.8.26-orig/misc/skins/gotar.ini mc-4.8.26/misc/skins/gotar.ini
--- mc-4.8.26-orig/misc/skins/gotar.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/gotar.ini	2021-02-13 11:01:18.957534164 +0000
@@ -36,7 +36,6 @@
     header = brightred;
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = brightcyan;blue
diff -Nuar mc-4.8.26-orig/misc/skins/gray-green-purple256.ini mc-4.8.26/misc/skins/gray-green-purple256.ini
--- mc-4.8.26-orig/misc/skins/gray-green-purple256.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/gray-green-purple256.ini	2021-02-13 11:01:18.957534164 +0000
@@ -45,7 +45,6 @@
     reverse =
     commandlinemark = ;main1
     header = main2
-    shadow = black;gray12
 
 [dialog]
     _default_ = black;bgdarker
diff -Nuar mc-4.8.26-orig/misc/skins/gray-orange-blue256.ini mc-4.8.26/misc/skins/gray-orange-blue256.ini
--- mc-4.8.26-orig/misc/skins/gray-orange-blue256.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/gray-orange-blue256.ini	2021-02-13 11:01:18.957534164 +0000
@@ -45,7 +45,6 @@
     reverse =
     commandlinemark = ;main1
     header = main2
-    shadow = black;gray12
 
 [dialog]
     _default_ = black;bgdarker
diff -Nuar mc-4.8.26-orig/misc/skins/julia256.ini mc-4.8.26/misc/skins/julia256.ini
--- mc-4.8.26-orig/misc/skins/julia256.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/julia256.ini	2021-02-13 11:01:18.957534164 +0000
@@ -42,7 +42,6 @@
     header = yellow;color237
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = black;lightgray
diff -Nuar mc-4.8.26-orig/misc/skins/mc46.ini mc-4.8.26/misc/skins/mc46.ini
--- mc-4.8.26-orig/misc/skins/mc46.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/mc46.ini	2021-02-13 11:01:18.957534164 +0000
@@ -39,7 +39,6 @@
     header = yellow;blue
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = black;lightgray
diff -Nuar mc-4.8.26-orig/misc/skins/modarcon16-defbg.ini mc-4.8.26/misc/skins/modarcon16-defbg.ini
--- mc-4.8.26-orig/misc/skins/modarcon16-defbg.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarcon16-defbg.ini	2021-02-13 11:01:18.957534164 +0000
@@ -81,7 +81,6 @@
     disabled = color8;color7
     #inputhistory =
     #commandhistory =
-    shadow = color7;color0
 
 [dialog]
     _default_ = color0;color7
diff -Nuar mc-4.8.26-orig/misc/skins/modarcon16.ini mc-4.8.26/misc/skins/modarcon16.ini
--- mc-4.8.26-orig/misc/skins/modarcon16.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarcon16.ini	2021-02-13 11:01:18.957534164 +0000
@@ -81,7 +81,6 @@
     disabled = color8;color7
     #inputhistory =
     #commandhistory =
-    shadow = color7;color0
 
 [dialog]
     _default_ = color0;color7
diff -Nuar mc-4.8.26-orig/misc/skins/modarcon16root-defbg.ini mc-4.8.26/misc/skins/modarcon16root-defbg.ini
--- mc-4.8.26-orig/misc/skins/modarcon16root-defbg.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarcon16root-defbg.ini	2021-02-13 11:01:18.957534164 +0000
@@ -81,7 +81,6 @@
     disabled = color8;color7
     #inputhistory =
     #commandhistory =
-    shadow = color7;color0
 
 [dialog]
     _default_ = color0;color7
diff -Nuar mc-4.8.26-orig/misc/skins/modarcon16root.ini mc-4.8.26/misc/skins/modarcon16root.ini
--- mc-4.8.26-orig/misc/skins/modarcon16root.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarcon16root.ini	2021-02-13 11:01:18.957534164 +0000
@@ -81,7 +81,6 @@
     disabled = color8;color7
     #inputhistory =
     #commandhistory =
-    shadow = color7;color0
 
 [dialog]
     _default_ = color0;color7
diff -Nuar mc-4.8.26-orig/misc/skins/modarin256-defbg.ini mc-4.8.26/misc/skins/modarin256-defbg.ini
--- mc-4.8.26-orig/misc/skins/modarin256-defbg.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarin256-defbg.ini	2021-02-13 11:01:18.960867543 +0000
@@ -81,7 +81,6 @@
     disabled = color246;color239
     #inputhistory =
     #commandhistory =
-    shadow = color240;color0
 
 [dialog]
     _default_ = color252;color239
diff -Nuar mc-4.8.26-orig/misc/skins/modarin256.ini mc-4.8.26/misc/skins/modarin256.ini
--- mc-4.8.26-orig/misc/skins/modarin256.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarin256.ini	2021-02-13 11:01:18.960867543 +0000
@@ -81,7 +81,6 @@
     disabled = color246;color239
     #inputhistory =
     #commandhistory =
-    shadow = color240;color0
 
 [dialog]
     _default_ = color252;color239
diff -Nuar mc-4.8.26-orig/misc/skins/modarin256root-defbg.ini mc-4.8.26/misc/skins/modarin256root-defbg.ini
--- mc-4.8.26-orig/misc/skins/modarin256root-defbg.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarin256root-defbg.ini	2021-02-13 11:01:18.960867543 +0000
@@ -81,7 +81,6 @@
     disabled = color246;color239
     #inputhistory =
     #commandhistory =
-    shadow = color240;color0
 
 [dialog]
     _default_ = color252;color239
diff -Nuar mc-4.8.26-orig/misc/skins/modarin256root.ini mc-4.8.26/misc/skins/modarin256root.ini
--- mc-4.8.26-orig/misc/skins/modarin256root.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/modarin256root.ini	2021-02-13 11:01:18.960867543 +0000
@@ -81,7 +81,6 @@
     disabled = color246;color239
     #inputhistory =
     #commandhistory =
-    shadow = color240;color0
 
 [dialog]
     _default_ = color252;color239
diff -Nuar mc-4.8.26-orig/misc/skins/nicedark.ini mc-4.8.26/misc/skins/nicedark.ini
--- mc-4.8.26-orig/misc/skins/nicedark.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/nicedark.ini	2021-02-13 11:01:18.960867543 +0000
@@ -39,7 +39,6 @@
     header = lightgray;black
     inputhistory =
     commandhistory =
-    shadow = gray;black
 
 [dialog]
     _default_ = lightgray;black
diff -Nuar mc-4.8.26-orig/misc/skins/sand256.ini mc-4.8.26/misc/skins/sand256.ini
--- mc-4.8.26-orig/misc/skins/sand256.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/sand256.ini	2021-02-13 11:01:18.960867543 +0000
@@ -94,7 +94,6 @@
     reverse = ;rgb452
     commandlinemark = white;gray
     header = red;;italic
-    shadow = black;rgb221
 
 [dialog]
     _default_ = black;rgb553
diff -Nuar mc-4.8.26-orig/misc/skins/seasons-autumn16M.ini mc-4.8.26/misc/skins/seasons-autumn16M.ini
--- mc-4.8.26-orig/misc/skins/seasons-autumn16M.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/seasons-autumn16M.ini	2021-02-13 11:01:18.960867543 +0000
@@ -65,8 +65,6 @@
     DialogFocus = #69880c
     Input = #b5c400
     PaleFg = #555
-    ShadowFg = #7f7f55
-    ShadowBg = #4c1002
     Error = #840000
     ErrorFocus = #b00
     Top = #ff9909
@@ -108,7 +106,6 @@
     reverse = #000;Bottom
     commandlinemark = #000;DialogFocus
     header = HeaderFg
-    shadow = ShadowFg;ShadowBg
 
 [dialog]
     _default_ = #000;Dialog
diff -Nuar mc-4.8.26-orig/misc/skins/seasons-spring16M.ini mc-4.8.26/misc/skins/seasons-spring16M.ini
--- mc-4.8.26-orig/misc/skins/seasons-spring16M.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/seasons-spring16M.ini	2021-02-13 11:01:18.960867543 +0000
@@ -65,8 +65,6 @@
     DialogFocus = #b3de85
     Input = Main
     PaleFg = #777
-    ShadowFg = #000
-    ShadowBg = #797f73
     Error = #c62b41
     ErrorFocus = #e16d7e
     Top = #f699a6
@@ -108,7 +106,6 @@
     reverse = #000;Bottom
     commandlinemark = #000;DialogFocus
     header = HeaderFg
-    shadow = ShadowFg;ShadowBg
 
 [dialog]
     _default_ = #000;Dialog
diff -Nuar mc-4.8.26-orig/misc/skins/seasons-summer16M.ini mc-4.8.26/misc/skins/seasons-summer16M.ini
--- mc-4.8.26-orig/misc/skins/seasons-summer16M.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/seasons-summer16M.ini	2021-02-13 11:01:18.960867543 +0000
@@ -65,8 +65,6 @@
     DialogFocus = #f864f6
     Input = #d7ffad
     PaleFg = #777
-    ShadowFg = #000
-    ShadowBg = #7f7659
     Error = #d40707
     ErrorFocus = #db7b7b
     Top = #46cef3
@@ -108,7 +106,6 @@
     reverse = #000;Bottom
     commandlinemark = #000;DialogFocus
     header = HeaderFg
-    shadow = ShadowFg;ShadowBg
 
 [dialog]
     _default_ = #000;Dialog
diff -Nuar mc-4.8.26-orig/misc/skins/seasons-winter16M.ini mc-4.8.26/misc/skins/seasons-winter16M.ini
--- mc-4.8.26-orig/misc/skins/seasons-winter16M.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/seasons-winter16M.ini	2021-02-13 11:01:18.960867543 +0000
@@ -65,8 +65,6 @@
     DialogFocus = #afbad8
     Input = Main
     PaleFg = #777
-    ShadowFg = #000
-    ShadowBg = #727176
     Error = #3c4766
     ErrorFocus = #586896
     Top = #6b99d7
@@ -108,7 +106,6 @@
     reverse = #000;Bottom
     commandlinemark = #000;DialogFocus
     header = HeaderFg
-    shadow = ShadowFg;ShadowBg
 
 [dialog]
     _default_ = #000;Dialog
diff -Nuar mc-4.8.26-orig/misc/skins/xoria256.ini mc-4.8.26/misc/skins/xoria256.ini
--- mc-4.8.26-orig/misc/skins/xoria256.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/xoria256.ini	2021-02-13 11:01:18.960867543 +0000
@@ -82,8 +82,6 @@
     #commandhistory =
     #commandlinemark = black;lightgray
 
-    shadow = color239;black
-
 [dialog]
     _default_ = black;color250
     dhotnormal = color88;;
diff -Nuar mc-4.8.26-orig/misc/skins/yadt256-defbg.ini mc-4.8.26/misc/skins/yadt256-defbg.ini
--- mc-4.8.26-orig/misc/skins/yadt256-defbg.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/yadt256-defbg.ini	2021-02-13 11:01:18.960867543 +0000
@@ -48,7 +48,6 @@
     disabled = color246;color239
     #inputhistory =
     #commandhistory =
-    shadow = color239;black
 
 [dialog]
     _default_ = color252;color239
diff -Nuar mc-4.8.26-orig/misc/skins/yadt256.ini mc-4.8.26/misc/skins/yadt256.ini
--- mc-4.8.26-orig/misc/skins/yadt256.ini	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/misc/skins/yadt256.ini	2021-02-13 11:01:18.960867543 +0000
@@ -47,7 +47,6 @@
     disabled = color246;color239
     #inputhistory =
     #commandhistory =
-    shadow = color239;black
 
 [dialog]
     _default_ = color252;color239
diff -Nuar mc-4.8.26-orig/src/filemanager/boxes.c mc-4.8.26/src/filemanager/boxes.c
--- mc-4.8.26-orig/src/filemanager/boxes.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/src/filemanager/boxes.c	2021-02-13 11:01:18.964200922 +0000
@@ -42,7 +42,6 @@
 #include "lib/global.h"
 
 #include "lib/tty/tty.h"
-#include "lib/tty/color.h"      /* tty_use_colors() */
 #include "lib/tty/key.h"        /* XCTRL and ALT macros  */
 #include "lib/skin.h"           /* INPUT_COLOR */
 #include "lib/mcconfig.h"       /* Load/save user formats */
@@ -119,8 +118,6 @@
 static WListbox *bg_list = NULL;
 #endif /* ENABLE_BACKGROUND */
 
-static unsigned long shadows_id;
-
 /* --------------------------------------------------------------------------------------------- */
 /*** file scope functions ************************************************************************/
 /* --------------------------------------------------------------------------------------------- */
@@ -275,38 +272,6 @@
 /* --------------------------------------------------------------------------------------------- */
 
 static cb_ret_t
-appearance_box_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
-{
-    switch (msg)
-    {
-    case MSG_INIT:
-        if (!tty_use_colors ())
-        {
-            Widget *shadow;
-
-            shadow = widget_find_by_id (w, shadows_id);
-            CHECK (shadow)->state = FALSE;
-            widget_disable (shadow, TRUE);
-        }
-        return MSG_HANDLED;
-
-    case MSG_NOTIFY:
-        if (sender != NULL && sender->id == shadows_id)
-        {
-            mc_global.tty.shadows = CHECK (sender)->state;
-            repaint_screen ();
-            return MSG_HANDLED;
-        }
-        return MSG_NOT_HANDLED;
-
-    default:
-        return dlg_default_callback (w, sender, msg, parm, data);
-    }
-}
-
-/* --------------------------------------------------------------------------------------------- */
-
-static cb_ret_t
 panel_listing_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
 {
     switch (msg)
@@ -624,8 +589,6 @@
 void
 appearance_box (void)
 {
-    gboolean shadows = mc_global.tty.shadows;
-
     current_skin_name = g_strdup (mc_skin__default.name);
     skin_names = mc_skin_list ();
 
@@ -638,8 +601,6 @@
                 QUICK_BUTTON (str_fit_to_term (skin_name_to_label (current_skin_name), 20, J_LEFT_FIT),
                               B_USER, sel_skin_button, NULL),
             QUICK_STOP_COLUMNS,
-            QUICK_SEPARATOR (TRUE),
-            QUICK_CHECKBOX (N_("&Shadows"), &mc_global.tty.shadows, &shadows_id),
             QUICK_BUTTONS_OK_CANCEL,
             QUICK_END
             /* *INDENT-ON* */
@@ -648,17 +609,14 @@
         quick_dialog_t qdlg = {
             -1, -1, 54,
             N_("Appearance"), "[Appearance]",
-            quick_widgets, appearance_box_callback, NULL
+            quick_widgets, dlg_default_callback, NULL
         };
 
         if (quick_dialog (&qdlg) == B_ENTER)
             mc_config_set_string (mc_global.main_config, CONFIG_APP_SECTION, "skin",
                                   current_skin_name);
         else
-        {
             skin_apply (NULL);
-            mc_global.tty.shadows = shadows;
-        }
     }
 
     g_free (current_skin_name);
diff -Nuar mc-4.8.26-orig/src/filemanager/boxes.c.orig mc-4.8.26/src/filemanager/boxes.c.orig
--- mc-4.8.26-orig/src/filemanager/boxes.c.orig	1970-01-01 00:00:00.000000000 +0000
+++ mc-4.8.26/src/filemanager/boxes.c.orig	2021-01-10 11:50:16.000000000 +0000
@@ -0,0 +1,1385 @@
+/*
+   Some misc dialog boxes for the program.
+
+   Copyright (C) 1994-2020
+   Free Software Foundation, Inc.
+
+   Written by:
+   Miguel de Icaza, 1994, 1995
+   Jakub Jelinek, 1995
+   Andrew Borodin <aborodin@vmail.ru>, 2009-2015
+
+   This file is part of the Midnight Commander.
+
+   The Midnight Commander is free software: you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation, either version 3 of the License,
+   or (at your option) any later version.
+
+   The Midnight Commander is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file boxes.c
+ *  \brief Source: Some misc dialog boxes for the program
+ */
+
+#include <config.h>
+
+#include <ctype.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "lib/global.h"
+
+#include "lib/tty/tty.h"
+#include "lib/tty/color.h"      /* tty_use_colors() */
+#include "lib/tty/key.h"        /* XCTRL and ALT macros  */
+#include "lib/skin.h"           /* INPUT_COLOR */
+#include "lib/mcconfig.h"       /* Load/save user formats */
+#include "lib/strutil.h"
+
+#include "lib/vfs/vfs.h"
+#ifdef ENABLE_VFS_FTP
+#include "src/vfs/ftpfs/ftpfs.h"
+#endif /* ENABLE_VFS_FTP */
+#ifdef ENABLE_VFS_SMB
+#include "src/vfs/smbfs/smbfs.h"
+#endif /* ENABLE_VFS_SMB */
+
+#include "lib/util.h"           /* Q_() */
+#include "lib/widget.h"
+
+#include "src/setup.h"
+#include "src/history.h"        /* MC_HISTORY_ESC_TIMEOUT */
+#include "src/execute.h"        /* pause_after_run */
+#ifdef ENABLE_BACKGROUND
+#include "src/background.h"     /* task_list */
+#endif
+
+#ifdef HAVE_CHARSET
+#include "lib/charsets.h"
+#include "src/selcodepage.h"
+#endif
+
+#include "command.h"            /* For cmdline */
+#include "dir.h"
+#include "tree.h"
+#include "layout.h"             /* for get_nth_panel_name proto */
+#include "filemanager.h"
+
+#include "boxes.h"
+
+/*** global variables ****************************************************************************/
+
+/*** file scope macro definitions ****************************************************************/
+
+#ifdef ENABLE_BACKGROUND
+#define B_STOP   (B_USER+1)
+#define B_RESUME (B_USER+2)
+#define B_KILL   (B_USER+3)
+#endif /* ENABLE_BACKGROUND */
+
+/*** file scope type declarations ****************************************************************/
+
+/*** file scope variables ************************************************************************/
+
+static unsigned long configure_old_esc_mode_id, configure_time_out_id;
+
+/* Index in list_formats[] for "brief" */
+static const int panel_list_brief_idx = 1;
+/* Index in list_formats[] for "user defined" */
+static const int panel_list_user_idx = 3;
+
+static char **status_format;
+static unsigned long panel_list_formats_id, panel_user_format_id, panel_brief_cols_id;
+static unsigned long user_mini_status_id, mini_user_format_id;
+
+#ifdef HAVE_CHARSET
+static int new_display_codepage;
+#endif /* HAVE_CHARSET */
+
+#if defined(ENABLE_VFS) && defined(ENABLE_VFS_FTP)
+static unsigned long ftpfs_always_use_proxy_id, ftpfs_proxy_host_id;
+#endif /* ENABLE_VFS && ENABLE_VFS_FTP */
+
+static GPtrArray *skin_names;
+static gchar *current_skin_name;
+
+#ifdef ENABLE_BACKGROUND
+static WListbox *bg_list = NULL;
+#endif /* ENABLE_BACKGROUND */
+
+static unsigned long shadows_id;
+
+/* --------------------------------------------------------------------------------------------- */
+/*** file scope functions ************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+configure_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    switch (msg)
+    {
+    case MSG_NOTIFY:
+        /* message from "Single press" checkbutton */
+        if (sender != NULL && sender->id == configure_old_esc_mode_id)
+        {
+            const gboolean not_single = !CHECK (sender)->state;
+            Widget *ww;
+
+            /* input line */
+            ww = widget_find_by_id (w, configure_time_out_id);
+            widget_disable (ww, not_single);
+
+            return MSG_HANDLED;
+        }
+        return MSG_NOT_HANDLED;
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static void
+skin_apply (const gchar * skin_override)
+{
+    GError *mcerror = NULL;
+
+    mc_skin_deinit ();
+    mc_skin_init (skin_override, &mcerror);
+    mc_fhl_free (&mc_filehighlight);
+    mc_filehighlight = mc_fhl_new (TRUE);
+    dlg_set_default_colors ();
+    input_set_default_colors ();
+    if (mc_global.mc_run_mode == MC_RUN_FULL)
+        command_set_default_colors ();
+    panel_deinit ();
+    panel_init ();
+    repaint_screen ();
+
+    mc_error_message (&mcerror, NULL);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static const gchar *
+skin_name_to_label (const gchar * name)
+{
+    if (strcmp (name, "default") == 0)
+        return _("< Default >");
+    return name;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+skin_dlg_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    switch (msg)
+    {
+    case MSG_RESIZE:
+        {
+            WDialog *d = DIALOG (w);
+            Widget *wd = WIDGET (d->data);
+            int y, x;
+            WRect r;
+
+            y = wd->y + (wd->lines - w->lines) / 2;
+            x = wd->x + wd->cols / 2;
+            rect_init (&r, y, x, w->lines, w->cols);
+
+            return dlg_default_callback (w, NULL, MSG_RESIZE, 0, &r);
+        }
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static int
+sel_skin_button (WButton * button, int action)
+{
+    int result;
+    WListbox *skin_list;
+    WDialog *skin_dlg;
+    const gchar *skin_name;
+    unsigned int i;
+    unsigned int pos = 1;
+
+    (void) action;
+
+    skin_dlg =
+        dlg_create (TRUE, 0, 0, 13, 24, WPOS_KEEP_DEFAULT, TRUE, dialog_colors, skin_dlg_callback,
+                    NULL, "[Appearance]", _("Skins"));
+    /* use Appearance dialog for positioning */
+    skin_dlg->data = WIDGET (button)->owner;
+
+    /* set dialog location before all */
+    send_message (skin_dlg, NULL, MSG_RESIZE, 0, NULL);
+
+    skin_list = listbox_new (1, 1, 11, 22, FALSE, NULL);
+    skin_name = "default";
+    listbox_add_item (skin_list, LISTBOX_APPEND_AT_END, 0, skin_name_to_label (skin_name),
+                      (void *) skin_name, FALSE);
+
+    if (strcmp (skin_name, current_skin_name) == 0)
+        listbox_select_entry (skin_list, 0);
+
+    for (i = 0; i < skin_names->len; i++)
+    {
+        skin_name = g_ptr_array_index (skin_names, i);
+        if (strcmp (skin_name, "default") != 0)
+        {
+            listbox_add_item (skin_list, LISTBOX_APPEND_AT_END, 0, skin_name_to_label (skin_name),
+                              (void *) skin_name, FALSE);
+            if (strcmp (skin_name, current_skin_name) == 0)
+                listbox_select_entry (skin_list, pos);
+            pos++;
+        }
+    }
+
+    /* make list stick to all sides of dialog, effectively make it be resized with dialog */
+    group_add_widget_autopos (GROUP (skin_dlg), skin_list, WPOS_KEEP_ALL, NULL);
+
+    result = dlg_run (skin_dlg);
+    if (result == B_ENTER)
+    {
+        gchar *skin_label;
+
+        listbox_get_current (skin_list, &skin_label, (void **) &skin_name);
+        g_free (current_skin_name);
+        current_skin_name = g_strdup (skin_name);
+        skin_apply (skin_name);
+
+        button_set_text (button, str_fit_to_term (skin_label, 20, J_LEFT_FIT));
+    }
+    dlg_destroy (skin_dlg);
+
+    return 0;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+appearance_box_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    switch (msg)
+    {
+    case MSG_INIT:
+        if (!tty_use_colors ())
+        {
+            Widget *shadow;
+
+            shadow = widget_find_by_id (w, shadows_id);
+            CHECK (shadow)->state = FALSE;
+            widget_disable (shadow, TRUE);
+        }
+        return MSG_HANDLED;
+
+    case MSG_NOTIFY:
+        if (sender != NULL && sender->id == shadows_id)
+        {
+            mc_global.tty.shadows = CHECK (sender)->state;
+            repaint_screen ();
+            return MSG_HANDLED;
+        }
+        return MSG_NOT_HANDLED;
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+panel_listing_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    switch (msg)
+    {
+    case MSG_NOTIFY:
+        if (sender != NULL && sender->id == panel_list_formats_id)
+        {
+            WCheck *ch;
+            WInput *in1, *in2, *in3;
+
+            in1 = INPUT (widget_find_by_id (w, panel_user_format_id));
+            in2 = INPUT (widget_find_by_id (w, panel_brief_cols_id));
+            ch = CHECK (widget_find_by_id (w, user_mini_status_id));
+            in3 = INPUT (widget_find_by_id (w, mini_user_format_id));
+
+            if (!ch->state)
+                input_assign_text (in3, status_format[RADIO (sender)->sel]);
+            input_update (in1, FALSE);
+            input_update (in2, FALSE);
+            input_update (in3, FALSE);
+            widget_disable (WIDGET (in1), RADIO (sender)->sel != panel_list_user_idx);
+            widget_disable (WIDGET (in2), RADIO (sender)->sel != panel_list_brief_idx);
+            return MSG_HANDLED;
+        }
+
+        if (sender != NULL && sender->id == user_mini_status_id)
+        {
+            WInput *in;
+
+            in = INPUT (widget_find_by_id (w, mini_user_format_id));
+
+            if (CHECK (sender)->state)
+            {
+                widget_disable (WIDGET (in), FALSE);
+                input_assign_text (in, status_format[3]);
+            }
+            else
+            {
+                WRadio *r;
+
+                r = RADIO (widget_find_by_id (w, panel_list_formats_id));
+                widget_disable (WIDGET (in), TRUE);
+                input_assign_text (in, status_format[r->sel]);
+            }
+            /* input_update (in, FALSE); */
+            return MSG_HANDLED;
+        }
+
+        return MSG_NOT_HANDLED;
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef HAVE_CHARSET
+static int
+sel_charset_button (WButton * button, int action)
+{
+    int new_dcp;
+
+    (void) action;
+
+    new_dcp = select_charset (-1, -1, new_display_codepage, TRUE);
+
+    if (new_dcp != SELECT_CHARSET_CANCEL)
+    {
+        const char *cpname;
+
+        new_display_codepage = new_dcp;
+        cpname = (new_display_codepage == SELECT_CHARSET_OTHER_8BIT) ?
+            _("Other 8 bit") :
+            ((codepage_desc *) g_ptr_array_index (codepages, new_display_codepage))->name;
+        if (cpname != NULL)
+            mc_global.utf8_display = str_isutf8 (cpname);
+        else
+            cpname = _("7-bit ASCII");  /* FIXME */
+
+        button_set_text (button, cpname);
+        widget_draw (WIDGET (WIDGET (button)->owner));
+    }
+
+    return 0;
+}
+#endif /* HAVE_CHARSET */
+
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+tree_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    WDialog *h = DIALOG (w);
+
+    switch (msg)
+    {
+    case MSG_RESIZE:
+        {
+            WRect r;
+            Widget *bar;
+
+            rect_init (&r, w->y, w->x, LINES - 9, COLS - 20);
+            dlg_default_callback (w, NULL, MSG_RESIZE, 0, &r);
+
+            bar = WIDGET (find_buttonbar (h));
+            bar->x = 0;
+            bar->y = LINES - 1;
+            return MSG_HANDLED;
+        }
+
+    case MSG_ACTION:
+        return send_message (find_tree (h), NULL, MSG_ACTION, parm, NULL);
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#if defined(ENABLE_VFS) && defined (ENABLE_VFS_FTP)
+static cb_ret_t
+confvfs_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    switch (msg)
+    {
+    case MSG_NOTIFY:
+        /* message from "Always use ftp proxy" checkbutton */
+        if (sender != NULL && sender->id == ftpfs_always_use_proxy_id)
+        {
+            const gboolean not_use = !CHECK (sender)->state;
+            Widget *wi;
+
+            /* input */
+            wi = widget_find_by_id (w, ftpfs_proxy_host_id);
+            widget_disable (wi, not_use);
+            return MSG_HANDLED;
+        }
+        return MSG_NOT_HANDLED;
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+#endif /* ENABLE_VFS && ENABLE_VFS_FTP */
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_BACKGROUND
+static void
+jobs_fill_listbox (WListbox * list)
+{
+    static const char *state_str[2] = { "", "" };
+    TaskList *tl;
+
+    if (state_str[0][0] == '\0')
+    {
+        state_str[0] = _("Running");
+        state_str[1] = _("Stopped");
+    }
+
+    for (tl = task_list; tl != NULL; tl = tl->next)
+    {
+        char *s;
+
+        s = g_strconcat (state_str[tl->state], " ", tl->info, (char *) NULL);
+        listbox_add_item (list, LISTBOX_APPEND_AT_END, 0, s, (void *) tl, FALSE);
+        g_free (s);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static int
+task_cb (WButton * button, int action)
+{
+    TaskList *tl;
+    int sig = 0;
+
+    (void) button;
+
+    if (bg_list->list == NULL)
+        return 0;
+
+    /* Get this instance information */
+    listbox_get_current (bg_list, NULL, (void **) &tl);
+
+#ifdef SIGTSTP
+    if (action == B_STOP)
+    {
+        sig = SIGSTOP;
+        tl->state = Task_Stopped;
+    }
+    else if (action == B_RESUME)
+    {
+        sig = SIGCONT;
+        tl->state = Task_Running;
+    }
+    else
+#endif
+    if (action == B_KILL)
+        sig = SIGKILL;
+
+    if (sig == SIGKILL)
+        unregister_task_running (tl->pid, tl->fd);
+
+    kill (tl->pid, sig);
+    listbox_remove_list (bg_list);
+    jobs_fill_listbox (bg_list);
+
+    /* This can be optimized to just redraw this widget :-) */
+    widget_draw (WIDGET (WIDGET (button)->owner));
+
+    return 0;
+}
+#endif /* ENABLE_BACKGROUND */
+
+/* --------------------------------------------------------------------------------------------- */
+/*** public functions ****************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+void
+configure_box (void)
+{
+    const char *pause_options[] = {
+        N_("&Never"),
+        N_("On dum&b terminals"),
+        N_("Alwa&ys")
+    };
+
+    int pause_options_num;
+
+    pause_options_num = G_N_ELEMENTS (pause_options);
+
+    {
+        char time_out[BUF_TINY] = "";
+        char *time_out_new;
+
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_START_GROUPBOX (N_("File operations")),
+                    QUICK_CHECKBOX (N_("&Verbose operation"), &verbose, NULL),
+                    QUICK_CHECKBOX (N_("Compute tota&ls"), &file_op_compute_totals, NULL),
+                    QUICK_CHECKBOX (N_("Classic pro&gressbar"), &classic_progressbar, NULL),
+                    QUICK_CHECKBOX (N_("Mkdi&r autoname"), &auto_fill_mkdir_name, NULL),
+                    QUICK_CHECKBOX (N_("&Preallocate space"), &mc_global.vfs.preallocate_space,
+                                    NULL),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("Esc key mode")),
+                    QUICK_CHECKBOX (N_("S&ingle press"), &old_esc_mode, &configure_old_esc_mode_id),
+                    QUICK_LABELED_INPUT (N_("Timeout:"), input_label_left,
+                                         (const char *) time_out, MC_HISTORY_ESC_TIMEOUT,
+                                         &time_out_new, &configure_time_out_id, FALSE, FALSE,
+                                         INPUT_COMPLETE_NONE),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("Pause after run")),
+                    QUICK_RADIO (pause_options_num, pause_options, &pause_after_run, NULL),
+                QUICK_STOP_GROUPBOX,
+            QUICK_NEXT_COLUMN,
+                QUICK_START_GROUPBOX (N_("Other options")),
+                    QUICK_CHECKBOX (N_("Use internal edi&t"), &use_internal_edit, NULL),
+                    QUICK_CHECKBOX (N_("Use internal vie&w"), &use_internal_view, NULL),
+                    QUICK_CHECKBOX (N_("A&sk new file name"),
+                                    &editor_ask_filename_before_edit, NULL),
+                    QUICK_CHECKBOX (N_("Auto m&enus"), &auto_menu, NULL),
+                    QUICK_CHECKBOX (N_("&Drop down menus"), &drop_menus, NULL),
+                    QUICK_CHECKBOX (N_("S&hell patterns"), &easy_patterns, NULL),
+                    QUICK_CHECKBOX (N_("Co&mplete: show all"),
+                                    &mc_global.widget.show_all_if_ambiguous, NULL),
+                    QUICK_CHECKBOX (N_("Rotating d&ash"), &nice_rotating_dash, NULL),
+                    QUICK_CHECKBOX (N_("Cd follows lin&ks"), &mc_global.vfs.cd_symlinks, NULL),
+                    QUICK_CHECKBOX (N_("Sa&fe delete"), &safe_delete, NULL),
+                    QUICK_CHECKBOX (N_("Safe overwrite"), &safe_overwrite, NULL),       /* w/o hotkey */
+                    QUICK_CHECKBOX (N_("A&uto save setup"), &auto_save_setup, NULL),
+                    QUICK_SEPARATOR (FALSE),
+                    QUICK_SEPARATOR (FALSE),
+                QUICK_STOP_GROUPBOX,
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 60,
+            N_("Configure options"), "[Configuration]",
+            quick_widgets, configure_callback, NULL
+        };
+
+        g_snprintf (time_out, sizeof (time_out), "%d", old_esc_mode_timeout);
+
+#ifndef USE_INTERNAL_EDIT
+        quick_widgets[17].state = WST_DISABLED;
+#endif
+
+        if (!old_esc_mode)
+            quick_widgets[10].state = quick_widgets[11].state = WST_DISABLED;
+
+#ifndef HAVE_POSIX_FALLOCATE
+        mc_global.vfs.preallocate_space = FALSE;
+        quick_widgets[7].state = WST_DISABLED;
+#endif
+
+        if (quick_dialog (&qdlg) == B_ENTER)
+            old_esc_mode_timeout = atoi (time_out_new);
+
+        g_free (time_out_new);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+appearance_box (void)
+{
+    gboolean shadows = mc_global.tty.shadows;
+
+    current_skin_name = g_strdup (mc_skin__default.name);
+    skin_names = mc_skin_list ();
+
+    {
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_LABEL (N_("Skin:"), NULL),
+            QUICK_NEXT_COLUMN,
+                QUICK_BUTTON (str_fit_to_term (skin_name_to_label (current_skin_name), 20, J_LEFT_FIT),
+                              B_USER, sel_skin_button, NULL),
+            QUICK_STOP_COLUMNS,
+            QUICK_SEPARATOR (TRUE),
+            QUICK_CHECKBOX (N_("&Shadows"), &mc_global.tty.shadows, &shadows_id),
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 54,
+            N_("Appearance"), "[Appearance]",
+            quick_widgets, appearance_box_callback, NULL
+        };
+
+        if (quick_dialog (&qdlg) == B_ENTER)
+            mc_config_set_string (mc_global.main_config, CONFIG_APP_SECTION, "skin",
+                                  current_skin_name);
+        else
+        {
+            skin_apply (NULL);
+            mc_global.tty.shadows = shadows;
+        }
+    }
+
+    g_free (current_skin_name);
+    g_ptr_array_foreach (skin_names, (GFunc) g_free, NULL);
+    g_ptr_array_free (skin_names, TRUE);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+panel_options_box (void)
+{
+    gboolean simple_swap;
+
+    simple_swap = mc_config_get_bool (mc_global.main_config, CONFIG_PANELS_SECTION,
+                                      "simple_swap", FALSE);
+    {
+        const char *qsearch_options[] = {
+            N_("Case &insensitive"),
+            N_("Cas&e sensitive"),
+            N_("Use panel sort mo&de")
+        };
+
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_START_GROUPBOX (N_("Main options")),
+                    QUICK_CHECKBOX (N_("Show mi&ni-status"), &panels_options.show_mini_info, NULL),
+                    QUICK_CHECKBOX (N_("Use SI si&ze units"), &panels_options.kilobyte_si, NULL),
+                    QUICK_CHECKBOX (N_("Mi&x all files"), &panels_options.mix_all_files, NULL),
+                    QUICK_CHECKBOX (N_("Show &backup files"), &panels_options.show_backups, NULL),
+                    QUICK_CHECKBOX (N_("Show &hidden files"), &panels_options.show_dot_files, NULL),
+                    QUICK_CHECKBOX (N_("&Fast dir reload"), &panels_options.fast_reload, NULL),
+                    QUICK_CHECKBOX (N_("Ma&rk moves down"), &panels_options.mark_moves_down, NULL),
+                    QUICK_CHECKBOX (N_("Re&verse files only"), &panels_options.reverse_files_only,
+                                    NULL),
+                    QUICK_CHECKBOX (N_("Simple s&wap"), &simple_swap, NULL),
+                    QUICK_CHECKBOX (N_("A&uto save panels setup"), &panels_options.auto_save_setup,
+                                    NULL),
+                    QUICK_SEPARATOR (FALSE),
+                    QUICK_SEPARATOR (FALSE),
+                    QUICK_SEPARATOR (FALSE),
+                QUICK_STOP_GROUPBOX,
+            QUICK_NEXT_COLUMN,
+                QUICK_START_GROUPBOX (N_("Navigation")),
+                    QUICK_CHECKBOX (N_("L&ynx-like motion"), &panels_options.navigate_with_arrows,
+                                    NULL),
+                    QUICK_CHECKBOX (N_("Pa&ge scrolling"), &panels_options.scroll_pages, NULL),
+                    QUICK_CHECKBOX (N_("Center &scrolling"), &panels_options.scroll_center, NULL),
+                    QUICK_CHECKBOX (N_("&Mouse page scrolling"), &panels_options.mouse_move_pages,
+                                    NULL),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("File highlight")),
+                    QUICK_CHECKBOX (N_("File &types"), &panels_options.filetype_mode, NULL),
+                    QUICK_CHECKBOX (N_("&Permissions"), &panels_options.permission_mode, NULL),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("Quick search")),
+                    QUICK_RADIO (QSEARCH_NUM, qsearch_options, (int *) &panels_options.qsearch_mode,
+                                 NULL),
+                QUICK_STOP_GROUPBOX,
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 60,
+            N_("Panel options"), "[Panel options]",
+            quick_widgets, NULL, NULL
+        };
+
+        if (quick_dialog (&qdlg) != B_ENTER)
+            return;
+    }
+
+    mc_config_set_bool (mc_global.main_config, CONFIG_PANELS_SECTION, "simple_swap", simple_swap);
+
+    if (!panels_options.fast_reload_msg_shown && panels_options.fast_reload)
+    {
+        message (D_NORMAL, _("Information"),
+                 _("Using the fast reload option may not reflect the exact\n"
+                   "directory contents. In this case you'll need to do a\n"
+                   "manual reload of the directory. See the man page for\n" "the details."));
+        panels_options.fast_reload_msg_shown = TRUE;
+    }
+
+    update_panels (UP_RELOAD, UP_KEEPSEL);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+/* return list type */
+int
+panel_listing_box (WPanel * panel, int num, char **userp, char **minip, gboolean * use_msformat,
+                   int *brief_cols)
+{
+    int result = -1;
+    const char *p = NULL;
+
+    if (panel == NULL)
+    {
+        p = get_nth_panel_name (num);
+        panel = panel_empty_new (p);
+    }
+
+    {
+        gboolean user_mini_status;
+        char panel_brief_cols_in[BUF_TINY];
+        char *panel_brief_cols_out = NULL;
+        char *panel_user_format = NULL;
+        char *mini_user_format = NULL;
+
+        /* Controls whether the array strings have been translated */
+        const char *list_formats[LIST_FORMATS] = {
+            N_("&Full file list"),
+            N_("&Brief file list:"),
+            N_("&Long file list"),
+            N_("&User defined:")
+        };
+
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_RADIO (LIST_FORMATS, list_formats, &result, &panel_list_formats_id),
+            QUICK_NEXT_COLUMN,
+                QUICK_SEPARATOR (FALSE),
+                QUICK_LABELED_INPUT (_ ("columns"), input_label_right, panel_brief_cols_in,
+                                     "panel-brief-cols-input", &panel_brief_cols_out,
+                                     &panel_brief_cols_id, FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_STOP_COLUMNS,
+            QUICK_INPUT (panel->user_format, "user-fmt-input", &panel_user_format,
+                         &panel_user_format_id, FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_SEPARATOR (TRUE),
+            QUICK_CHECKBOX (N_("User &mini status"), &user_mini_status, &user_mini_status_id),
+            QUICK_INPUT (panel->user_status_format[panel->list_format], "mini_input",
+                         &mini_user_format, &mini_user_format_id, FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 48,
+            N_("Listing format"), "[Listing Format...]",
+            quick_widgets, panel_listing_callback, NULL
+        };
+
+        user_mini_status = panel->user_mini_status;
+        result = panel->list_format;
+        status_format = panel->user_status_format;
+
+        g_snprintf (panel_brief_cols_in, sizeof (panel_brief_cols_in), "%d", panel->brief_cols);
+
+        if ((int) panel->list_format != panel_list_brief_idx)
+            quick_widgets[4].state = WST_DISABLED;
+
+        if ((int) panel->list_format != panel_list_user_idx)
+            quick_widgets[6].state = WST_DISABLED;
+
+        if (!user_mini_status)
+            quick_widgets[9].state = WST_DISABLED;
+
+        if (quick_dialog (&qdlg) == B_CANCEL)
+            result = -1;
+        else
+        {
+            int cols;
+            char *error = NULL;
+
+            *userp = panel_user_format;
+            *minip = mini_user_format;
+            *use_msformat = user_mini_status;
+
+            cols = strtol (panel_brief_cols_out, &error, 10);
+            if (*error == '\0')
+                *brief_cols = cols;
+            else
+                *brief_cols = panel->brief_cols;
+
+            g_free (panel_brief_cols_out);
+        }
+    }
+
+    if (p != NULL)
+    {
+        int i;
+
+        g_free (panel->user_format);
+        for (i = 0; i < LIST_FORMATS; i++)
+            g_free (panel->user_status_format[i]);
+        g_free (panel);
+    }
+
+    return result;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+const panel_field_t *
+sort_box (dir_sort_options_t * op, const panel_field_t * sort_field)
+{
+    char **sort_orders_names;
+    gsize i;
+    gsize sort_names_num = 0;
+    int sort_idx = 0;
+    const panel_field_t *result = NULL;
+
+    sort_orders_names = panel_get_sortable_fields (&sort_names_num);
+
+    for (i = 0; i < sort_names_num; i++)
+        if (strcmp (sort_orders_names[i], _(sort_field->title_hotkey)) == 0)
+        {
+            sort_idx = i;
+            break;
+        }
+
+    {
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_RADIO (sort_names_num, (const char **) sort_orders_names, &sort_idx, NULL),
+            QUICK_NEXT_COLUMN,
+                QUICK_CHECKBOX (N_("Executable &first"), &op->exec_first, NULL),
+                QUICK_CHECKBOX (N_("Cas&e sensitive"), &op->case_sensitive, NULL),
+                QUICK_CHECKBOX (N_("&Reverse"), &op->reverse, NULL),
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 40,
+            N_("Sort order"), "[Sort Order...]",
+            quick_widgets, NULL, NULL
+        };
+
+        if (quick_dialog (&qdlg) != B_CANCEL)
+            result = panel_get_field_by_title_hotkey (sort_orders_names[sort_idx]);
+
+        if (result == NULL)
+            result = sort_field;
+    }
+
+    g_strfreev (sort_orders_names);
+
+    return result;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+confirm_box (void)
+{
+    quick_widget_t quick_widgets[] = {
+        /* *INDENT-OFF* */
+        /* TRANSLATORS: no need to translate 'Confirmation', it's just a context prefix */
+        QUICK_CHECKBOX (Q_("Confirmation|&Delete"), &confirm_delete, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|O&verwrite"), &confirm_overwrite, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|&Execute"), &confirm_execute, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|E&xit"), &confirm_exit, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|Di&rectory hotlist delete"),
+                        &confirm_directory_hotlist_delete, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|&History cleanup"),
+                        &mc_global.widget.confirm_history_cleanup, NULL),
+        QUICK_BUTTONS_OK_CANCEL,
+        QUICK_END
+        /* *INDENT-ON* */
+    };
+
+    quick_dialog_t qdlg = {
+        -1, -1, 46,
+        N_("Confirmation"), "[Confirmation]",
+        quick_widgets, NULL, NULL
+    };
+
+    (void) quick_dialog (&qdlg);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifndef HAVE_CHARSET
+void
+display_bits_box (void)
+{
+    gboolean new_meta;
+    int current_mode;
+
+    const char *display_bits_str[] = {
+        N_("&UTF-8 output"),
+        N_("&Full 8 bits output"),
+        N_("&ISO 8859-1"),
+        N_("7 &bits")
+    };
+
+    quick_widget_t quick_widgets[] = {
+        /* *INDENT-OFF* */
+        QUICK_RADIO (4, display_bits_str, &current_mode, NULL),
+        QUICK_SEPARATOR (TRUE),
+        QUICK_CHECKBOX (N_("F&ull 8 bits input"), &new_meta, NULL),
+        QUICK_BUTTONS_OK_CANCEL,
+        QUICK_END
+        /* *INDENT-ON* */
+    };
+
+    quick_dialog_t qdlg = {
+        -1, -1, 46,
+        _("Display bits"), "[Display bits]",
+        quick_widgets, NULL, NULL
+    };
+
+    if (mc_global.full_eight_bits)
+        current_mode = 0;
+    else if (mc_global.eight_bit_clean)
+        current_mode = 1;
+    else
+        current_mode = 2;
+
+    new_meta = !use_8th_bit_as_meta;
+
+    if (quick_dialog (&qdlg) != B_CANCEL)
+    {
+        mc_global.eight_bit_clean = current_mode < 3;
+        mc_global.full_eight_bits = current_mode < 2;
+#ifndef HAVE_SLANG
+        tty_display_8bit (mc_global.eight_bit_clean);
+#else
+        tty_display_8bit (mc_global.full_eight_bits);
+#endif
+        use_8th_bit_as_meta = !new_meta;
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+#else /* HAVE_CHARSET */
+
+void
+display_bits_box (void)
+{
+    const char *cpname;
+
+    new_display_codepage = mc_global.display_codepage;
+
+    cpname = (new_display_codepage < 0) ? _("Other 8 bit")
+        : ((codepage_desc *) g_ptr_array_index (codepages, new_display_codepage))->name;
+
+    {
+        gboolean new_meta;
+
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_LABEL (N_("Input / display codepage:"), NULL),
+            QUICK_NEXT_COLUMN,
+                QUICK_BUTTON (cpname, B_USER, sel_charset_button, NULL),
+            QUICK_STOP_COLUMNS,
+            QUICK_SEPARATOR (TRUE),
+                QUICK_CHECKBOX (N_("F&ull 8 bits input"), &new_meta, NULL),
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 46,
+            N_("Display bits"), "[Display bits]",
+            quick_widgets, NULL, NULL
+        };
+
+        new_meta = !use_8th_bit_as_meta;
+        application_keypad_mode ();
+
+        if (quick_dialog (&qdlg) == B_ENTER)
+        {
+            char *errmsg;
+
+            mc_global.display_codepage = new_display_codepage;
+
+            errmsg = init_translation_table (mc_global.source_codepage, mc_global.display_codepage);
+            if (errmsg != NULL)
+            {
+                message (D_ERROR, MSG_ERROR, "%s", errmsg);
+                g_free (errmsg);
+            }
+
+#ifdef HAVE_SLANG
+            tty_display_8bit (mc_global.display_codepage != 0 && mc_global.display_codepage != 1);
+#else
+            tty_display_8bit (mc_global.display_codepage != 0);
+#endif
+            use_8th_bit_as_meta = !new_meta;
+
+            repaint_screen ();
+        }
+    }
+}
+#endif /* HAVE_CHARSET */
+
+/* --------------------------------------------------------------------------------------------- */
+/** Show tree in a box, not on a panel */
+
+char *
+tree_box (const char *current_dir)
+{
+    WTree *mytree;
+    WDialog *dlg;
+    WGroup *g;
+    Widget *wd;
+    char *val = NULL;
+    WButtonBar *bar;
+
+    (void) current_dir;
+
+    /* Create the components */
+    dlg = dlg_create (TRUE, 0, 0, LINES - 9, COLS - 20, WPOS_CENTER, FALSE, dialog_colors,
+                      tree_callback, NULL, "[Directory Tree]", _("Directory tree"));
+    g = GROUP (dlg);
+    wd = WIDGET (dlg);
+
+    mytree = tree_new (2, 2, wd->lines - 6, wd->cols - 5, FALSE);
+    group_add_widget_autopos (g, mytree, WPOS_KEEP_ALL, NULL);
+    group_add_widget_autopos (g, hline_new (wd->lines - 4, 1, -1), WPOS_KEEP_BOTTOM, NULL);
+    bar = buttonbar_new (TRUE);
+    group_add_widget (g, bar);
+    /* restore ButtonBar coordinates after add_widget() */
+    WIDGET (bar)->x = 0;
+    WIDGET (bar)->y = LINES - 1;
+
+    if (dlg_run (dlg) == B_ENTER)
+    {
+        const vfs_path_t *selected_name;
+
+        selected_name = tree_selected_name (mytree);
+        val = g_strdup (vfs_path_as_str (selected_name));
+    }
+
+    dlg_destroy (dlg);
+    return val;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_VFS
+void
+configure_vfs_box (void)
+{
+    char buffer2[BUF_TINY];
+#ifdef ENABLE_VFS_FTP
+    char buffer3[BUF_TINY];
+
+    g_snprintf (buffer3, sizeof (buffer3), "%i", ftpfs_directory_timeout);
+#endif
+
+    g_snprintf (buffer2, sizeof (buffer2), "%i", vfs_timeout);
+
+    {
+        char *ret_timeout;
+#ifdef ENABLE_VFS_FTP
+        char *ret_passwd;
+        char *ret_ftp_proxy;
+        char *ret_directory_timeout;
+#endif /* ENABLE_VFS_FTP */
+
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_LABELED_INPUT (N_("Timeout for freeing VFSs (sec):"), input_label_left,
+                                 buffer2, "input-timo-vfs", &ret_timeout, NULL, FALSE, FALSE,
+                                 INPUT_COMPLETE_NONE),
+#ifdef ENABLE_VFS_FTP
+            QUICK_SEPARATOR (TRUE),
+            QUICK_LABELED_INPUT (N_("FTP anonymous password:"), input_label_left,
+                                 ftpfs_anonymous_passwd, "input-passwd", &ret_passwd, NULL,
+                                 FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_LABELED_INPUT (N_("FTP directory cache timeout (sec):"), input_label_left,
+                                 buffer3, "input-timeout", &ret_directory_timeout, NULL,
+                                 FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_CHECKBOX (N_("&Always use ftp proxy:"), &ftpfs_always_use_proxy,
+                            &ftpfs_always_use_proxy_id),
+            QUICK_INPUT (ftpfs_proxy_host, "input-ftp-proxy", &ret_ftp_proxy,
+                         &ftpfs_proxy_host_id, FALSE, FALSE, INPUT_COMPLETE_HOSTNAMES),
+            QUICK_CHECKBOX (N_("&Use ~/.netrc"), &ftpfs_use_netrc, NULL),
+            QUICK_CHECKBOX (N_("Use &passive mode"), &ftpfs_use_passive_connections, NULL),
+            QUICK_CHECKBOX (N_("Use passive mode over pro&xy"),
+                            &ftpfs_use_passive_connections_over_proxy, NULL),
+#endif /* ENABLE_VFS_FTP */
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 56,
+            N_("Virtual File System Setting"), "[Virtual FS]",
+            quick_widgets,
+#ifdef ENABLE_VFS_FTP
+            confvfs_callback,
+#else
+            NULL,
+#endif
+            NULL,
+        };
+
+#ifdef ENABLE_VFS_FTP
+        if (!ftpfs_always_use_proxy)
+            quick_widgets[5].state = WST_DISABLED;
+#endif
+
+        if (quick_dialog (&qdlg) != B_CANCEL)
+        {
+            /* cppcheck-suppress uninitvar */
+            vfs_timeout = atoi (ret_timeout);
+            g_free (ret_timeout);
+
+            if (vfs_timeout < 0 || vfs_timeout > 10000)
+                vfs_timeout = 10;
+#ifdef ENABLE_VFS_FTP
+            g_free (ftpfs_anonymous_passwd);
+            /* cppcheck-suppress uninitvar */
+            ftpfs_anonymous_passwd = ret_passwd;
+            g_free (ftpfs_proxy_host);
+            /* cppcheck-suppress uninitvar */
+            ftpfs_proxy_host = ret_ftp_proxy;
+            /* cppcheck-suppress uninitvar */
+            ftpfs_directory_timeout = atoi (ret_directory_timeout);
+            g_free (ret_directory_timeout);
+#endif
+        }
+    }
+}
+
+#endif /* ENABLE_VFS */
+
+/* --------------------------------------------------------------------------------------------- */
+
+char *
+cd_box (const WPanel * panel)
+{
+    const Widget *w = CONST_WIDGET (panel);
+    char *my_str;
+
+    quick_widget_t quick_widgets[] = {
+        QUICK_LABELED_INPUT (N_("cd"), input_label_left, "", "input", &my_str, NULL, FALSE, TRUE,
+                             INPUT_COMPLETE_FILENAMES | INPUT_COMPLETE_CD),
+        QUICK_END
+    };
+
+    quick_dialog_t qdlg = {
+        w->y + w->lines - 6, w->x, w->cols,
+        N_("Quick cd"), "[Quick cd]",
+        quick_widgets, NULL, NULL
+    };
+
+    return (quick_dialog (&qdlg) != B_CANCEL) ? my_str : NULL;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+symlink_box (const vfs_path_t * existing_vpath, const vfs_path_t * new_vpath,
+             char **ret_existing, char **ret_new)
+{
+    quick_widget_t quick_widgets[] = {
+        /* *INDENT-OFF* */
+        QUICK_LABELED_INPUT (N_("Existing filename (filename symlink will point to):"),
+                             input_label_above, vfs_path_as_str (existing_vpath), "input-2",
+                             ret_existing, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES),
+        QUICK_SEPARATOR (FALSE),
+        QUICK_LABELED_INPUT (N_("Symbolic link filename:"), input_label_above,
+                             vfs_path_as_str (new_vpath), "input-1",
+                             ret_new, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES),
+        QUICK_BUTTONS_OK_CANCEL,
+        QUICK_END
+        /* *INDENT-ON* */
+    };
+
+    quick_dialog_t qdlg = {
+        -1, -1, 64,
+        N_("Symbolic link"), "[File Menu]",
+        quick_widgets, NULL, NULL
+    };
+
+    if (quick_dialog (&qdlg) == B_CANCEL)
+    {
+        *ret_new = NULL;
+        *ret_existing = NULL;
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_BACKGROUND
+void
+jobs_box (void)
+{
+    struct
+    {
+        const char *name;
+        int flags;
+        int value;
+        int len;
+        bcback_fn callback;
+    }
+    job_but[] =
+    {
+        /* *INDENT-OFF* */
+        { N_("&Stop"), NORMAL_BUTTON, B_STOP, 0, task_cb },
+        { N_("&Resume"), NORMAL_BUTTON, B_RESUME, 0, task_cb },
+        { N_("&Kill"), NORMAL_BUTTON, B_KILL, 0, task_cb },
+        { N_("&OK"), DEFPUSH_BUTTON, B_CANCEL, 0, NULL }
+        /* *INDENT-ON* */
+    };
+
+    size_t i;
+    const size_t n_but = G_N_ELEMENTS (job_but);
+
+    WDialog *jobs_dlg;
+    WGroup *g;
+    int cols = 60;
+    int lines = 15;
+    int x = 0;
+
+    for (i = 0; i < n_but; i++)
+    {
+#ifdef ENABLE_NLS
+        job_but[i].name = _(job_but[i].name);
+#endif /* ENABLE_NLS */
+
+        job_but[i].len = str_term_width1 (job_but[i].name) + 3;
+        if (job_but[i].flags == DEFPUSH_BUTTON)
+            job_but[i].len += 2;
+        x += job_but[i].len;
+    }
+
+    x += (int) n_but - 1;
+    cols = MAX (cols, x + 6);
+
+    jobs_dlg = dlg_create (TRUE, 0, 0, lines, cols, WPOS_CENTER, FALSE, dialog_colors, NULL, NULL,
+                           "[Background jobs]", _("Background jobs"));
+    g = GROUP (jobs_dlg);
+
+    bg_list = listbox_new (2, 2, lines - 6, cols - 6, FALSE, NULL);
+    jobs_fill_listbox (bg_list);
+    group_add_widget (g, bg_list);
+
+    group_add_widget (g, hline_new (lines - 4, -1, -1));
+
+    x = (cols - x) / 2;
+    for (i = 0; i < n_but; i++)
+    {
+        group_add_widget (g, button_new (lines - 3, x, job_but[i].value, job_but[i].flags,
+                                         job_but[i].name, job_but[i].callback));
+        x += job_but[i].len + 1;
+    }
+
+    (void) dlg_run (jobs_dlg);
+    dlg_destroy (jobs_dlg);
+}
+#endif /* ENABLE_BACKGROUND */
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_VFS_SMB
+struct smb_authinfo *
+vfs_smb_get_authinfo (const char *host, const char *share, const char *domain, const char *user)
+{
+    char *label;
+    struct smb_authinfo *return_value = NULL;
+
+    if (domain == NULL)
+        domain = "";
+    if (user == NULL)
+        user = "";
+
+    label = g_strdup_printf (_("Password for \\\\%s\\%s"), host, share);
+
+    {
+        char *ret_domain, *ret_user, *ret_password;
+
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_LABEL (label, NULL),
+            QUICK_SEPARATOR (TRUE),
+            QUICK_START_COLUMNS,
+                QUICK_LABEL (N_("Domain:"), NULL),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_LABEL (N_("Username:"), NULL),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_LABEL (N_("Password:"), NULL),
+            QUICK_NEXT_COLUMN,
+                QUICK_INPUT (domain, "auth_domain", &ret_domain, NULL, FALSE, FALSE, INPUT_COMPLETE_HOSTNAMES),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_INPUT (user, "auth_name", &ret_user, NULL, FALSE, FALSE, INPUT_COMPLETE_USERNAMES),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_INPUT ("", "auth_password", &ret_password, NULL, TRUE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 40,
+            N_("SMB authentication"), "[Smb Authinfo]",
+            quick_widgets, NULL, NULL
+        };
+
+        if (quick_dialog (&qdlg) != B_CANCEL)
+        {
+            return_value = vfs_smb_authinfo_new (host, share, ret_domain, ret_user, ret_password);
+
+            g_free (ret_domain);
+            g_free (ret_user);
+            g_free (ret_password);
+        }
+    }
+
+    g_free (label);
+
+    return return_value;
+}
+#endif /* ENABLE_VFS_SMB */
+
+/* --------------------------------------------------------------------------------------------- */
diff -Nuar mc-4.8.26-orig/src/setup.c mc-4.8.26/src/setup.c
--- mc-4.8.26-orig/src/setup.c	2021-01-10 11:50:16.000000000 +0000
+++ mc-4.8.26/src/setup.c	2021-02-13 11:01:18.964200922 +0000
@@ -360,7 +360,6 @@
 #endif /* USE_INTERNAL_EDIT */
     { "editor_ask_filename_before_edit", &editor_ask_filename_before_edit },
     { "nice_rotating_dash", &nice_rotating_dash },
-    { "shadows", &mc_global.tty.shadows },
     { "mcview_remember_file_position", &mcview_remember_file_position },
     { "auto_fill_mkdir_name", &auto_fill_mkdir_name },
     { "copymove_persistent_attr", &copymove_persistent_attr },
